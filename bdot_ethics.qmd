---
title: "Banded Dotterel Tagging Trial"
date: "`r format(Sys.time(), '%d %B, %Y')`"
author: 
 - name: Luke Eberhart-Hertel
   orcid: 0000-0001-7311-6088
   email: luke.eberhart@bi.mpg.de
   url: https://www.bi.mpg.de/person/115852/2867
   affiliations:
     - ref: bk
 - name: Ailsa Howard
   affiliations:
     - ref: ah
 - name: Tony Habraken
   affiliations:
     - ref: th
 - name: Colin O`Donnell
   affiliations:
     - ref: ew
 - name: Clemens KÃ¼pper
   affiliations:
     - ref: ck
 - name: Emma Williams
   affiliations:
     - ref: ew
 - name: Bart Kempenaers
   affiliations:
     - ref: bk
affiliations:
 - id: bk
   number: 1
   name: Department of Ornithology, Max Planck Institute for Biological Intelligence, Seewiesen, Germany
 - id: ah
   number: 2
   name: South Bay Banded Dotterel Project, Kaikoura, New Zealand
 - id: th
   number: 2
   name: Port Waikato Banded Dotterel Project, Port Waikato, New Zealand
 - id: ew
   number: 3
   name: Department of Conservation, Christchurch, New Zealand
    - id: bk
   number: 1
   name: Research Group for Behavioural Genetics and Evolutionary Ecology, Max Planck Institute for Biological Intelligence, Seewiesen, Germany
format: 
  html:
    toc: true
    code-fold: true
    code-tools: true
    self-contained: true
    highlight-style: github
    theme: Cosmo
execute:
  warning: false
  cache: true
editor_options: 
  chunk_output_type: console
---
```{r}
knitr::opts_chunk$set(cache = TRUE)
```

```{r, message=FALSE, results='hide', warning=FALSE, results='hide', cache=FALSE, include=FALSE}
## Prerequisites

### R packages

# -   The following packages are needed for analysis and can be easily installed from [CRAN](http://cran.r-project.org/) or GitHub by running the following code chunk:

# a vector of all the packages needed in the project
packages_required_in_project <- c("dbo", "data.table", "apis", "stringr", "glue", 
                                  "mapview", "sf", "DBI", "tidyverse", "hms", 
                                  "stringr", "remotes", "googlesheets4", 
                                  "corrplot", "smatr", "lme4", "broom.mixed", 
                                  "gtsummary", "RColorBrewer", "rptR", "partR2",
                                  "multcomp", "effects", "gt", "scales", "readxl", 
                                  "colorspace", "showtext", "MuMIn", "here", "nnet",
                                  "brms", "ggeffects", "RMark", "tidybayes")

# of the required packages, check if some need to be installed
new.packages <- 
  packages_required_in_project[!(packages_required_in_project %in% 
                                   installed.packages()[,"Package"])]

# remotes::install_github("mpio-be/dbo")
# remotes::install_github("mpio-be/apis")

# install all packages that are not locally available
if(length(new.packages)) install.packages(new.packages)

# load all the packages into the current R session
lapply(packages_required_in_project, require, character.only = TRUE)

# set the home directory to where the project is locally based (i.e., to find 
# the relevant datasets to import, etc.
here::set_here()
```

```{r, message=FALSE, results='hide', warning=FALSE, include=FALSE}
### Plotting themes

# -   The following plotting themes, colors, and typefaces are used throughout the project:

# Find fonts from computer that you want. Use regular expressions to do this
# For example, load all fonts that are 'verdana' or 'Verdana'
extrafont::font_import(pattern = "[V/v]erdana", prompt = FALSE) 

# check which fonts were loaded
extrafont::fonts()
extrafont::fonttable()
extrafont::loadfonts() # load these into R

# define the plotting theme to be used in subsequent ggplots
luke_theme <- 
  theme_bw() +
  theme(
    text = element_text(family = "Verdana"),
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 8),
    axis.title.x = element_text(size = 10),
    axis.text.x  = element_text(size = 8), 
    axis.title.y = element_text(size = 10),
    axis.text.y = element_text(size = 8),
    strip.text = element_text(size = 10),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.ticks = element_line(linewidth = 0.5, colour = "grey40"),
    axis.ticks.length = unit(0.2, "cm"),
    panel.border = element_rect(linetype = "solid", colour = "grey"),
    legend.position.inside = c(0.1, 0.9)
  )
```

# Body Condition Dynamics
### Data import and wrangle
```{r}
### import and wrangle ----
# 2024 data 
# establish a connection to the entire database (i.e., that I have access to)
con = dbcon()

# connect to the FIELD_2024_BADOatNZ local database
dbExecute(con, "USE FIELD_2024_BADOatNZ")

# query to select everything from the "incoming" table
caps_2024 <-
  dbq(con, "SELECT * FROM CAPTURES") %>% 
  filter(age != "J") %>% 
  rowwise() %>%
  mutate(time = as_hms(min(cap_start, caught, released, na.rm = TRUE))) %>% 
    mutate(UL = ifelse(is.na(UL) | UL == "" | UL == "X", "XX", UL),
           LL = ifelse(is.na(LL) | LL == "" | LL == "X", "XX", LL),
           UR = ifelse(is.na(UR) | UR == "" | UR == "X", "XX", UR),
           LR = ifelse(is.na(LR) | LR == "" | LR == "X", "XX", LR)) %>% 
    mutate(UL = ifelse(UL == "M", "MX", UL),
           UR = ifelse(UR == "M", "MX", UR)) %>% 
  mutate(code = paste0(UL,".", LL, "|", UR,".", LR)) %>% 
  mutate(code = str_remove_all(code, ",")) %>% 
  dplyr::select(site, ring, code, field_sex, age, date, time, weight, culmen, tarsus, total_head, wing, wt_w_tag, tag_action, tag_id) %>%
  # remove pre-nesting females (weights are confounded by oogenisis)
  filter(ring != "CP19336" & weight != 66.6) %>% 
  filter(ring != "CP9088" & weight != 75.2) %>% 
  filter(ring != "CP16483" & weight != 63.8)# %>% 
  # filter(ring == "CP16134")

# pre-2024 data 
caps_pre2024 <-
  read_sheet("https://docs.google.com/spreadsheets/d/1Tp26Z23HSXXZSoGXD4dbP3xukhrY1kWhzQrbtRHt4EY/edit?usp=sharing", 
             sheet = "Captures", col_types = "c") %>% 
  dplyr::filter(age == "A") %>% 
  filter(species == "BADO") %>% 
  filter(!is.na(date)) %>% 
  mutate(date = paste(year, ifelse(nchar(date) == 3,
                                   substring(date, first = 2, last = 3),
                                   substring(date, first = 3, last = 4)),
                      ifelse(nchar(date) == 3,
                             substring(date, first = 1, last = 1),
                             substring(date, first = 1, last = 2)),
                      sep = "-") %>% as.Date()) %>% 
  mutate(time = str_pad(time, width = 4, side = "left", pad = "0")) %>% 
  mutate(time = paste0(substr(time, 1, 2), ":", substr(time, 3, 4), ":00") %>% as_hms) %>%
  mutate(left_tarsus = ifelse(ring == "CP9066" & left_tarsus == 20.4, 30.4, left_tarsus),
         right_tarsus = ifelse(ring == "CP9066" & right_tarsus == 20.3, 30.3, right_tarsus)) %>% 
  mutate(left_tarsus = as.numeric(left_tarsus),
         right_tarsus = as.numeric(right_tarsus),
         left_wing = as.numeric(left_wing),
         right_wing = as.numeric(right_wing),
         weight = as.numeric(weight),
         bill = as.numeric(bill)) %>% 
  mutate(tarsus = rowMeans(cbind(left_tarsus, right_tarsus), na.rm = TRUE),
         wing = rowMeans(cbind(left_wing, right_wing), na.rm = TRUE)) %>% 
  rename(culmen = bill, 
         tag_id = tag,
         nest_id = ID) %>% 
  dplyr::select(site, ring, code, field_sex, age, date, time, weight, culmen, tarsus, wing, tag_id)
  
colour_band = 0.08
metal_band = 0.16

# bind together
all_caps <-
  bind_rows(caps_2024, caps_pre2024) %>% 
  arrange(ring, date, time) %>% 
  mutate(tag = ifelse(is.na(tag_id) | nchar(tag_id) < 2, 0, 1)) %>% 
  group_by(ring) %>% 
  mutate(culmen = mean(culmen, na.rm = TRUE), 
         tarsus = mean(tarsus, na.rm = TRUE), 
         total_head = mean(total_head, na.rm = TRUE), 
         wing = mean(wing, na.rm = TRUE)) %>% 
  mutate(weight = weight - ((4 * colour_band) + metal_band))

# tag deployment information
tag_info <- 
  read.csv("/Users/leberhart/ownCloud/kemp_projects/bdot/data/field/Kaikoura_tag_and_control_weights_Luke_2021_2022.csv") %>% 
  dplyr::select(ring, tag, tag_type, treatment_group) %>% 
  filter(tag != 0) %>% 
  distinct() %>% 
  rename(tag_id = tag) %>% 
  mutate(tag_id = as.character(tag_id))

all_caps_KK <- 
  all_caps %>%
  filter(site == "KK") %>%
  left_join(., tag_info, by = c("ring", "tag_id")) %>% 
  group_by(ring) %>% 
  mutate(tag_type = ifelse(is.na(tag_type), first(na.omit(tag_type)), tag_type),
         treatment_group = ifelse(is.na(treatment_group), first(na.omit(treatment_group)), treatment_group)) %>%
  ungroup() %>% 
  mutate(treatment_group = ifelse(is.na(treatment_group) & (is.na(tag_id) | tag_id == "0"), "control", 
                                  ifelse(is.na(treatment_group) & !is.na(tag_id), "tagged", treatment_group))) %>% 
  
  ungroup() %>% 
  mutate(tag_type = ifelse(tag_type == "2g_tag", "PTT", 
                           ifelse(tag_type == "1.3g_tag", "GPS", tag_type))) %>% 
  mutate(tag_type = ifelse(treatment_group == "control", "control", tag_type)) %>% 
  mutate(tag_type = ifelse(tag_id == "07EC" & is.na(tag_type), "Druid", tag_type)) %>% 
  mutate(tag_type = ifelse(tag_id == "21107" & is.na(tag_type), "GPS", tag_type)) %>%
  mutate(tag_type = ifelse(ring == "CP9097" & year(date) == 2022, "GPS", tag_type)) %>% 
  mutate(treatment_group = ifelse(ring == "CP9097" & year(date) == 2022, "tagged", treatment_group)) %>% 
  mutate(code = ifelse(ring == "CP9075", "XX.RR|MX.BB", 
                       ifelse(ring == "CP16614", "XX.RB|MX.WB", code))) %>% 
  filter(tag_type != "Druid")

# saveRDS(all_caps_KK, "data/all_caps_KK.rds")
all_caps_KK <- 
  readRDS("data/all_caps_KK.rds")
```

### PCA of structural traits
```{r}
#### check most relevent structural traits with PCA ----
# PCA of static body structural measurements (culmen, tarsus, wing)
static_measures_pca_KK <-
  all_caps_KK %>% 
  group_by(ring) %>% 
  arrange(date, time) %>% 
  slice(1) %>% 
  ungroup() %>% 
  dplyr::select(culmen, tarsus, wing) %>%
  na.omit() %>% 
  princomp()

# check the PCA results
summary(static_measures_pca_KK)
biplot(static_measures_pca_KK, cex = 0.7)

# bind PC scores to the original dataframe
all_caps_pca_KK <-
  all_caps_KK %>% 
  group_by(ring) %>% 
  arrange(date, time) %>% 
  slice(1) %>% 
  ungroup() %>% 
  dplyr::select(ring, date, time, culmen, tarsus, wing, weight) %>%
  bind_cols(., static_measures_pca_KK$scores[, 1], static_measures_pca_KK$scores[, 2], static_measures_pca_KK$scores[, 3]) %>% 
  rename(structure_pc1 = `...8`,
         structure_pc2 = `...9`,
         structure_pc3 = `...10`) %>% 
  na.omit()

# check correlations of traits with weight to determine best trait to use for SMI
all_caps_pca_KK %>% 
  mutate(log_weight = log(weight),
         log_culmen = log(culmen),
         log_tarsus = log(tarsus),
         log_wing = log(wing)) %>%
  dplyr::select(log_weight, log_culmen, log_tarsus, log_wing, structure_pc1, structure_pc2, structure_pc3) %>% 
  cor() %>% 
  corrplot(type = "upper", method = "number", tl.srt = 45)

# plots
ggplot(all_caps_pca_KK, 
       aes(x = structure_pc1, y = weight)) + 
  geom_point() + 
  labs(x = "PC1", y = "Body Mass") + 
  theme_minimal()

ggplot(all_caps_pca_KK, 
       aes(x = structure_pc2, y = weight)) + 
  geom_point() + 
  labs(x = "PC2", y = "Body Mass") + 
  theme_minimal()

ggplot(all_caps_pca_KK, 
       aes(x = structure_pc3, y = weight)) + 
  geom_point() + 
  labs(x = "PC3", y = "Body Mass") + 
  theme_minimal()

ggplot(all_caps_pca_KK, 
       aes(x = wing, y = weight)) + 
  geom_point() + 
  labs(x = "wing length", y = "Body Mass") + 
  theme_minimal()

ggplot(all_caps_pca_KK, 
       aes(x = wing, y = tarsus)) + 
  geom_point() + 
  labs(x = "tarsus length", y = "Body Mass") + 
  theme_minimal()

```

### Scaled Mass Index wrangle
```{r}
#### wrangle scaled mass index ("smi", sensu Peig & Green) ----

# average all repeated measures of structural traits for each bird
# (i.e., variation within individuals for these traits is assumed to be 
# observer/instrument error)
all_caps_KK_ <- 
  all_caps_KK %>% 
  group_by(ring) %>% 
  mutate(culmen = mean(culmen, na.rm = TRUE), 
         tarsus = mean(tarsus, na.rm = TRUE), 
         wing = mean(wing, na.rm = TRUE)) 

# determine which structural trait to use (see text in Peig and Green after Eq. 2
# "...We recommend the use of thatsingle L variable which has the strongest 
# correlation with M on a log-log scale, since this is likely to be the L that 
# best explains that fraction of mass associated with structural size")
cor.test(log(all_caps_KK_$tarsus), log(all_caps_KK_$weight)) # r = 0.118
cor.test(log(all_caps_KK_$wing), log(all_caps_KK_$weight)) # r = 0.208
cor.test(log(all_caps_KK_$culmen), log(all_caps_KK_$weight)) # r = 0.117

# conclude to use wing for SMI transformation because it has the largest r and 
# based on the PCA investigation above, wing did just as good as PC1 when 
# explaining variation in weight

# estimate the slope of the log-weight and log-wing SMA regression
weight_wing_sma_slope <- coef(sma(log(all_caps_KK_$weight) ~ log(all_caps_KK_$wing)))[2]

# calculate the average sizes of structural traits
avg_wing <- 
  all_caps_KK_ %>% 
  pull(wing) %>% 
  mean(., na.rm = TRUE)

scaledMassIndex <-
  function(x, y, x.0 = mean(x)) {
    require(smatr)
    require(magrittr)
    require(MASS)
    require(data.table)
    logM.ols <- lm(log(y) ~ log(x))
    logM.rob <- rlm(log(y) ~ log(x), method = "M")
    b.msa.ols <- coef(sma(log(y) ~ log(x)))[2]
    b.msa.rob <- coef(sma(log(y) ~ log(x), robust = T))[2]
    SMI.ols <- y * (x.0 / x) ^ b.msa.ols
    SMI.rob <- y * (x.0 / x) ^ b.msa.rob
    res <- data.frame(SMI.ols, SMI.rob, x, y)
    pred.DT <-
      data.table(x = seq(min(x), max(x), length = 100)) %>%
      .[, y.ols := predict(logM.ols, newdata = .) %>% exp] %>%
      .[, y.rob := predict(logM.rob, newdata = .) %>% exp]
    attr(res, "b.msa") <- c(ols = b.msa.ols, rob = b.msa.rob)
    return(res)
  }

smi_ <- 
  scaledMassIndex(x = all_caps_KK_ %>% 
                    ungroup() %>% 
                    dplyr::select(weight, wing) %>% 
                    na.omit() %>% 
                    pull(wing), 
                  y = all_caps_KK_ %>% 
                    ungroup() %>% 
                    dplyr::select(weight, wing) %>% 
                    na.omit() %>% 
                    pull(weight))

# calculate scaled mass index for full dataset (see Eq 2 of Peig and Green)
all_caps_KK_smi <-
  all_caps_KK_  %>% 
  filter(!is.na(weight)) %>% 
  bind_cols(., smi_) %>% 
  mutate(smi_wing = weight * (avg_wing/wing)^weight_wing_sma_slope) %>% 
  dplyr::select(smi_wing, weight, date, tag_type, treatment_group, ring, SMI.ols, SMI.rob) %>% 
  na.omit() %>% 
  # scale date variable to aid interpretation of model intercept
  mutate(date_ = as.numeric(scale(date, center = TRUE, scale = FALSE)))

ggplot(all_caps_KK_smi, 
       aes(x = smi_wing, y = SMI.rob)) + 
  geom_point() + 
  labs(x = "smi_wing", y = "SMI.ols") + 
  theme_minimal()
```

### Scaled Mass Index temporal model
```{r}
#### mixed effects regression ----
# smi_wing_lmer <-
#   lmer(smi_wing ~ date_ + tag_type + (1 | ring),
#        data = all_caps_KK_smi)

smi_wing_lmer_ols <-
  lmer(SMI.ols ~ date_ + tag_type + (1 | ring),
       data = all_caps_KK_smi)

# smi_wing_lmer_rob <-
#   lmer(SMI.rob ~ date_ + tag_type + (1 | ring),
#        data = all_caps_KK_smi)

# Derive confidence intervals of effect sizes from parametric bootstrapping
# tidy_smi_wing_lmer <-
#   tidy(smi_wing_lmer, conf.int = TRUE, conf.method = "boot", nsim = 1000)

tidy_smi_wing_lmer_ols <-
  tidy(smi_wing_lmer_ols, conf.int = TRUE, conf.method = "boot", nsim = 1000)

# tidy_smi_wing_lmer_rob <-
#   tidy(smi_wing_lmer_rob, conf.int = TRUE, conf.method = "boot", nsim = 1000)

# run rptR to obtain repeatabilities of random effects
# rpt_smi_wing_lmer <-
#   rpt(smi_wing ~ date_ + tag_type + (1 | ring),
#       grname = c("ring", "Fixed"),
#       data = all_caps_KK_smi,
#       datatype = "Gaussian",
#       nboot = 1000, npermut = 1000, ratio = TRUE,
#       adjusted = TRUE, ncores = 4, parallel = TRUE)

rpt_smi_wing_lmer_ols <-
  rpt(SMI.ols ~ date_ + tag_type + (1 | ring),
      grname = c("ring", "Fixed"),
      data = all_caps_KK_smi,
      datatype = "Gaussian",
      nboot = 1000, npermut = 1000, ratio = TRUE,
      adjusted = TRUE, ncores = 4, parallel = TRUE)

# rpt_smi_wing_lmer__ <-
#   rpt(SMI.rob ~ date_ + tag_type + (1 | ring),
#       grname = c("ring", "Fixed"),
#       data = all_caps_KK_smi,
#       datatype = "Gaussian",
#       nboot = 1000, npermut = 1000, ratio = TRUE,
#       adjusted = TRUE, ncores = 4, parallel = TRUE)

# run partR2 on each model to obtain marginal R2, parameter estimates, and beta
# weights
# R2m_smi_wing_lmer <-
#   partR2(smi_wing_lmer,
#          partvars = c("date_",
#                       "tag_type"),
#          R2_type = "marginal",
#          nboot = 1000,
#          CI = 0.95,
#          max_level = 1)

R2m_smi_wing_lmer_ols <-
  partR2(smi_wing_lmer_ols,
         partvars = c("date_",
                      "tag_type"),
         R2_type = "marginal",
         nboot = 1000,
         CI = 0.95,
         max_level = 1)

# R2m_smi_wing_lmer__ <-
#   partR2(smi_wing_lmer__,
#          partvars = c("date_",
#                       "tag_type"),
#          R2_type = "marginal",
#          nboot = 1000,
#          CI = 0.95,
#          max_level = 1)

# R2c_smi_wing_lmer <-
#   partR2(smi_wing_lmer,
#          partvars = c("date_",
#                       "tag_type"),
#          R2_type = "conditional",
#          nboot = 1000,
#          CI = 0.95,
#          max_level = 1)

R2c_smi_wing_lmer_ols <-
  partR2(smi_wing_lmer_ols,
         partvars = c("date_",
                      "tag_type"),
         R2_type = "conditional",
         nboot = 1000,
         CI = 0.95,
         max_level = 1)

# R2c_smi_wing_lmer__ <-
#   partR2(smi_wing_lmer__,
#          partvars = c("date_",
#                       "tag_type"),
#          R2_type = "conditional",
#          nboot = 1000,
#          CI = 0.95,
#          max_level = 1)

# stats_smi_wing_lmer <-
#   list(mod = smi_wing_lmer,
#        tidy = tidy_smi_wing_lmer,
#        rptR = rpt_smi_wing_lmer,
#        partR2m = R2m_smi_wing_lmer,
#        partR2c = R2c_smi_wing_lmer,
#        data = all_caps_KK_smi)

stats_smi_wing_lmer_ols <-
  list(mod = smi_wing_lmer_ols,
       tidy = tidy_smi_wing_lmer_ols,
       rptR = rpt_smi_wing_lmer_ols,
       partR2m = R2m_smi_wing_lmer_ols,
       partR2c = R2c_smi_wing_lmer_ols,
       data = all_caps_KK_smi)

# stats_smi_wing_lmer__ <-
#   list(mod = smi_wing_lmer__,
#        tidy = tidy_smi_wing_lmer__,
#        rptR = rpt_smi_wing_lmer__,
#        partR2m = R2m_smi_wing_lmer__,
#        partR2c = R2c_smi_wing_lmer__,
#        data = all_caps_KK_smi)

# summary(glht(smi_wing_lmer))
summary(glht(smi_wing_lmer_ols))
# summary(glht(smi_wing_lmer__))

#### Table of effect sizes ----
# Retrieve sample sizes
sample_sizes <-
  all_caps_KK_smi %>%
  ungroup() %>%
  summarise(Individual = n_distinct(ring),
            Observations = nrow(.))

sample_sizes <-
  as.data.frame(t(as.data.frame(sample_sizes))) %>%
  rownames_to_column("term") %>%
  rename(estimate = V1) %>%
  mutate(stat = "n")

# clean model component names
mod_comp_names <-
  data.frame(comp_name = c("Intercept (scaled mass index)",
                           "Within ind. temporal change",
                           "1.3g GPS tag",
                           "1.8g PTT tag",
                           "Total Marginal \U1D479\U00B2",
                           "Within ind. temporal change",
                           "Tag type",
                           "Total Conditional \U1D479\U00B2",
                           "Individual",
                           "Residual",
                           "Individual",
                           "Residual",
                           "Individuals",
                           "Observations"))

# Fixed effect sizes (non-standardized)
fixefTable <-
  stats_smi_wing_lmer_ols$tidy %>%
  dplyr::filter(effect == "fixed") %>%
  dplyr::select(term, estimate, conf.low, conf.high) %>%
  as.data.frame() %>%
  mutate(stat = "fixed")

# Fixed effect sizes (standardized)
fixef_bw_Table <-
  stats_smi_wing_lmer_ols$partR2m$BW %>%
  as.data.frame() %>%
  mutate(stat = "fixed_bw") %>%
  rename(conf.low = CI_lower,
         conf.high = CI_upper)

# Semi-partial R2 estimates
R2Table <-
  bind_rows(stats_smi_wing_lmer_ols$partR2m$R2,
            stats_smi_wing_lmer_ols$partR2c$R2[1,]) %>%
  dplyr::select(term, estimate, CI_lower, CI_upper) %>%
  as.data.frame() %>%
  mutate(stat = "partR2") %>%
  rename(conf.low = CI_lower,
         conf.high = CI_upper)

# Random effects variances
ranefTable <-
  stats_smi_wing_lmer_ols$tidy %>%
  dplyr::filter(effect == "ran_pars") %>%
  dplyr::select(group, estimate, conf.low, conf.high) %>%
  as.data.frame() %>%
  mutate(stat = "rand") %>%
  rename(term = group) %>%
  mutate(estimate = estimate^2,
         conf.high = conf.high^2,
         conf.low = conf.low^2)

# Adjusted repeatabilities
coefRptTable <-
  stats_smi_wing_lmer_ols$rptR$R_boot %>%
  dplyr::select(-Fixed) %>%
  mutate(residual = 1 - rowSums(.)) %>%
  apply(., 2,
        function(x) c(mean (x), quantile (x, prob = c(0.025, 0.975)))) %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("term") %>%
  rename(estimate = V1,
         conf.low = `2.5%`,
         conf.high = `97.5%`) %>%
  mutate(stat = "RptR")

# Store all parameters into a single table and clean it up
allCoefs_mod <-
  bind_rows(fixefTable[1,], 
            fixef_bw_Table,
            R2Table,
            ranefTable,
            coefRptTable,
            sample_sizes) %>%
  bind_cols(.,
            mod_comp_names) %>%
  mutate(coefString = ifelse(!is.na(conf.low),
                             paste0("[",
                                    round(conf.low, 2), ", ",
                                    round(conf.high, 2), "]"),
                             NA),
         effect = c(rep("Fixed effects \U1D6FD (standardized)", nrow(fixefTable[1,])),
                    rep("Fixed effects \U1D6FD (standardized)", nrow(fixef_bw_Table)),
                    rep("Partitioned \U1D479\U00B2", nrow(R2Table)),
                    rep("Random effects \U1D70E\U00B2", nrow(ranefTable)),
                    rep("Adjusted repeatability \U1D45F", nrow(coefRptTable)),
                    rep("Sample sizes \U1D45B", nrow(sample_sizes)))) %>%
  dplyr::select(effect, everything())

# draw gt table
smi_wing_lmer_table <-
  allCoefs_mod %>%
  dplyr::select(effect, comp_name, estimate, coefString) %>%
  gt(rowname_col = "row",
     groupname_col = "effect") %>%
  cols_label(comp_name = html("<i> </i>"),
             estimate = "Mean estimate",
             coefString = "95% confidence interval") %>%
  fmt_number(columns = c(estimate),
             rows = 1:12,
             decimals = 2,
             use_seps = FALSE) %>%
  fmt_number(columns = c(estimate),
             rows = 13:14,
             decimals = 0,
             use_seps = FALSE) %>%
  sub_missing(columns = 1:4,
              missing_text = "") %>%
  cols_align(align = "left",
             columns = c(comp_name)) %>%
  tab_options(row_group.font.weight = "bold",
              row_group.background.color = brewer.pal(9,"Greys")[3],
              table.font.size = 12,
              data_row.padding = 3,
              row_group.padding = 4,
              summary_row.padding = 2,
              column_labels.font.size = 14,
              row_group.font.size = 12,
              table.width = pct(70))

smi_wing_lmer_table
```

### Scaled Mass Index sequential measures model
```{r}
#### sequence of measures ----
# determine the first obs for birds that had repeated measures
first_obs <- 
  all_caps_KK_smi %>%
  group_by(ring) %>% 
  # mutate(n_obs = n()) %>% 
  # filter(n_obs > 1) %>% 
  filter(year(date) > 2020) %>% 
  arrange(ring, date) %>% 
  # group_by(ring) %>% 
  slice(1) %>% 
  rename(first_smi_wing = SMI.ols, 
         first_weight = weight,
         first_date = date) %>% 
  dplyr::select(ring, first_date, first_weight, first_smi_wing, tag_type, treatment_group)

# wrangle the repeated measures data
repeated_measures <-
  all_caps_KK_smi %>%
  group_by(ring) %>% 
  mutate(n_obs = n()) %>% 
  filter(n_obs > 1) %>% 
  filter(year(date) > 2020) %>% 
  arrange(ring, date) %>% 
  group_by(ring) %>% 
  slice(2) %>% 
  rename(second_smi_wing = SMI.ols,
         second_weight = weight,
         second_date = date) %>% 
  dplyr::select(ring, second_date, second_weight, second_smi_wing, tag_type, treatment_group) %>% 
  full_join(first_obs, ., join_by(ring, tag_type, treatment_group)) %>%
  mutate(smi_wing_diff = second_smi_wing - first_smi_wing,
         date_diff = second_date - first_date) %>%
  pivot_longer(
    cols = c(first_date, first_smi_wing, first_weight,
             second_date, second_smi_wing, second_weight),
    names_to = c("measure", ".value"),
    names_pattern = "(first|second)_(.*)"
  ) %>% 
  filter(!is.na(smi_wing)) %>% 
  dplyr::select(-smi_wing_diff)

repeated_measures %>% 
  group_by(tag_type) %>% 
  summarise(n = n_distinct(ring))

#### stats ----
smi_wing_lmer_seq <- 
  lmer(smi_wing ~ tag_type * measure + (1 | ring), 
       data = repeated_measures)

# Set or adjust priors if necessary
prior <- c(
  set_prior("normal(0, 10)", class = "b"),
  set_prior("cauchy(0, 2)", class = "sd")
)

smi_wing_brm <- brm(
  smi_wing ~ tag_type * measure + (1 | ring), 
  data = repeated_measures,
  family = gaussian(), 
  prior = prior, 
  chains = 4, 
  cores = 4, 
  iter = 4000,  
  warmup = 2000
)

# Summary of the brms model
summary(smi_wing_brm)

# Check Effective Sample Size and R-hat
print(smi_wing_brm)

# Plot the posterior distributions
plot(smi_wing_brm)

# Posterior predictive checks
pp_check(smi_wing_brm)

# Derive confidence intervals of effect sizes from parametric bootstrapping
tidy_smi_wing_lmer_seq <-
  tidy(smi_wing_lmer_seq, conf.int = TRUE, conf.method = "boot", nsim = 1000)

tidy_smi_wing_brm <-
  tidy(smi_wing_brm, conf.int = TRUE)

# run rptR to obtain repeatabilities of random effects
rpt_smi_wing_lmer_seq <-
  rpt(smi_wing ~ tag_type * measure + (1 | ring),
      grname = c("ring", "Fixed"),
      data = repeated_measures,
      datatype = "Gaussian",
      nboot = 1000, npermut = 1000, ratio = TRUE,
      adjusted = TRUE, ncores = 4, parallel = TRUE)

# run partR2 on each model to obtain marginal R2, parameter estimates, and beta
# weights
R2m_smi_wing_lmer_seq <-
  partR2(smi_wing_lmer_seq,
         partvars = c("tag_type",
                      "measure"),
         R2_type = "marginal",
         nboot = 1000,
         CI = 0.95,
         max_level = 1)

R2c_smi_wing_lmer_seq <-
  partR2(smi_wing_lmer_seq,
         partvars = c("tag_type",
                      "measure"),
         R2_type = "conditional",
         nboot = 1000,
         CI = 0.95,
         max_level = 1)

stats_smi_wing_lmer_seq <-
  list(mod = smi_wing_lmer_seq,
       tidy = tidy_smi_wing_lmer_seq,
       rptR = rpt_smi_wing_lmer_seq,
       partR2m = R2m_smi_wing_lmer_seq,
       partR2c = R2c_smi_wing_lmer_seq,
       data = repeated_measures)

# summary(glht(smi_wing_lmer_seq))

#### Table of effect sizes ----
# Retrieve sample sizes
sample_sizes <-
  stats_smi_wing_lmer_seq$data %>%
  ungroup() %>%
  summarise(Individual = n_distinct(ring),
            Observations = nrow(.))

sample_sizes <-
  as.data.frame(t(as.data.frame(sample_sizes))) %>%
  rownames_to_column("term") %>%
  rename(estimate = V1) %>%
  mutate(stat = "n")

# clean model component names
mod_comp_names <-
  data.frame(comp_name = c("Control group SMI (g; baseline intercept))",
                           "Relative SMI (g) of 1.3g GPS tag group",
                           "Relative SMI (g) of 1.8g PTT tag group",
                           "\u0394 SMI (g) in control group",
                           "Additional \u0394 SMI (g) for 1.3g GPS tag",
                           "Additional \u0394 SMI (g) for 1.8g PTT tag",
                           "Total Marginal \U1D479\U00B2",
                           "Tag type",
                           "Measurement sequence",
                           "Total Conditional \U1D479\U00B2",
                           "Individual",
                           "Residual",
                           "Individual",
                           "Residual",
                           "Individuals",
                           "Observations"))

# Fixed effect sizes (non-standardized)
fixefTable <-
  stats_smi_wing_lmer_seq$tidy %>%
  dplyr::filter(effect == "fixed") %>%
  dplyr::select(term, estimate, conf.low, conf.high) %>%
  as.data.frame() %>%
  mutate(stat = "fixed")

# Fixed effect sizes (standardized)
fixef_bw_Table <-
  stats_smi_wing_lmer_seq$partR2m$BW %>%
  as.data.frame() %>%
  mutate(stat = "fixed_bw") %>%
  rename(conf.low = CI_lower,
         conf.high = CI_upper)

# Semi-partial R2 estimates
R2Table <-
  bind_rows(stats_smi_wing_lmer_seq$partR2m$R2,
            stats_smi_wing_lmer_seq$partR2c$R2[1,]) %>%
  dplyr::select(term, estimate, CI_lower, CI_upper) %>%
  as.data.frame() %>%
  mutate(stat = "partR2") %>%
  rename(conf.low = CI_lower,
         conf.high = CI_upper)

# Random effects variances
ranefTable <-
  stats_smi_wing_lmer_seq$tidy %>%
  dplyr::filter(effect == "ran_pars") %>%
  dplyr::select(group, estimate, conf.low, conf.high) %>%
  as.data.frame() %>%
  mutate(stat = "rand") %>%
  rename(term = group) %>%
  mutate(estimate = estimate^2,
         conf.high = conf.high^2,
         conf.low = conf.low^2)

# Adjusted repeatabilities
coefRptTable <-
  stats_smi_wing_lmer_seq$rptR$R_boot %>%
  dplyr::select(-Fixed) %>%
  mutate(residual = 1 - rowSums(.)) %>%
  apply(., 2,
        function(x) c(mean (x), quantile (x, prob = c(0.025, 0.975)))) %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("term") %>%
  rename(estimate = V1,
         conf.low = `2.5%`,
         conf.high = `97.5%`) %>%
  mutate(stat = "RptR")

# Store all parameters into a single table and clean it up
allCoefs_mod <-
  bind_rows(fixefTable[1,], 
            fixef_bw_Table,
            R2Table,
            ranefTable,
            coefRptTable,
            sample_sizes) %>%
  bind_cols(.,
            mod_comp_names) %>%
  mutate(coefString = ifelse(!is.na(conf.low),
                             paste0("[",
                                    round(conf.low, 2), ", ",
                                    round(conf.high, 2), "]"),
                             NA),
         effect = c(rep("Fixed effects \U1D6FD (standardized)", nrow(fixefTable[1,])),
                    rep("Fixed effects \U1D6FD (standardized)", nrow(fixef_bw_Table)),
                    rep("Partitioned \U1D479\U00B2", nrow(R2Table)),
                    rep("Random effects \U1D70E\U00B2", nrow(ranefTable)),
                    rep("Adjusted repeatability \U1D45F", nrow(coefRptTable)),
                    rep("Sample sizes \U1D45B", nrow(sample_sizes)))) %>%
  dplyr::select(effect, everything())

# draw gt table
smi_wing_lmer_seq_table <-
  allCoefs_mod %>%
  dplyr::select(effect, comp_name, estimate, coefString) %>%
  gt(rowname_col = "row",
     groupname_col = "effect") %>%
  cols_label(comp_name = html("<i> </i>"),
             estimate = "Mean estimate",
             coefString = "95% confidence interval") %>%
  fmt_number(columns = c(estimate),
             rows = 1:14,
             decimals = 2,
             use_seps = FALSE) %>%
  fmt_number(columns = c(estimate),
             rows = 15:16,
             decimals = 0,
             use_seps = FALSE) %>%
  sub_missing(columns = 1:4,
              missing_text = "") %>%
  cols_align(align = "left",
             columns = c(comp_name)) %>%
  tab_options(row_group.font.weight = "bold",
              row_group.background.color = brewer.pal(9,"Greys")[3],
              table.font.size = 12,
              data_row.padding = 3,
              row_group.padding = 4,
              summary_row.padding = 2,
              column_labels.font.size = 14,
              row_group.font.size = 12,
              table.width = pct(75))

smi_wing_lmer_seq_table

# Load the MuMIn package for R-squared calculation
library(MuMIn)

# Calculate R-squared values
r.squared <- r.squaredGLMM(smi_wing_lmer_seq)
print(r.squared)

#### plotting ----
bdot_treatment_group_facets <- c('GPS' = "1.3g GPS tag", 
                                 'PTT' = "1.8g PTT tag", 
                                 'control' = "control")

bdot_breeding_fate_facets <- c('aband' = "abandoned", 
                                 'fail' = "nest failure", 
                                 'brood' = "hatched",
                               'fledge' = "fledged chicks",
                               'unkn' = "unknown fate")


custom_colors <- brewer.pal(9, "Pastel1")[c(9, 2, 3)]

# Add Google font Lato
font_add_google("Lato", "lato")

# Automatically use showtext to render text
showtext_auto()

repeated_measures_ <- 
  repeated_measures %>%
  mutate(x_line = ifelse(measure == "first", as.numeric(factor(measure)) + 0.15,
                         ifelse(measure == "second", as.numeric(factor(measure)) - 0.15, NA)),
         x_point = ifelse(measure == "first", as.numeric(factor(measure)), 
                          ifelse(measure == "second", as.numeric(factor(measure)), NA)))

ggplot(data = repeated_measures_) + 
  geom_line(aes(x = x_line, y = smi_wing, group = ring), color = "grey40", alpha = 0.5) + 
  geom_jitter(size = 6, aes(x = x_point, y = smi_wing, fill = tag_type, shape = measure), 
             shape = 21, color = "grey40", alpha = 1, width = 0.075) +
  # scale_shape_manual(values = c(21, 24)) +
  scale_fill_manual(values = custom_colors) +
  facet_grid(~ tag_type, labeller = as_labeller(bdot_treatment_group_facets)) +
  theme(legend.position = "none",
        text = element_text(family = "lato"),
        axis.title = element_text(size = 11, colour = "grey40"),
        axis.ticks = element_blank(),
        # axis.ticks.length = unit(0.1, "cm"),
        axis.text = element_text(size = 10, colour = "grey40"),
        axis.title.y = element_text(size = 12),
        axis.text.y = element_text(size = 10),
        plot.margin = unit(c(0.2,0.2,0.2,0.2), "cm"),
        panel.background = element_rect(fill = 'transparent', color = NA),
        plot.background = element_rect(fill = 'transparent', color = NA), 
        strip.background = element_rect(fill = 'transparent', color = NA),
        strip.text = element_text(size = 13, colour = "grey40"),
        panel.grid.major.y = element_line(size = 0.25, lineend = "round", colour = "grey90"),
        panel.grid.minor = element_blank()) +
  scale_x_continuous(limits = c(0.8, 2.2), breaks = c(1, 2), labels = c("first", "second")) +
  # scale_y_continuous(limits = c(43, 73)) +
  # geom_hline(yintercept = sum(PTT, harness, 4 * colour_band, metal_band) / 0.043,
  #            color = "grey", linetype = "dashed") +
  # geom_hline(yintercept = sum(GPS, harness, 4 * colour_band, metal_band) / 0.043,
  #            color = "grey", linetype = "dashed") +
  xlab("capture event") +
  ylab("scaled body mass index (g)")# +
  # geom_hline(data = subset(repeated_measures_, tag_type == "PTT"), aes(yintercept = sum(PTT, harness, 4 * colour_band, metal_band) / 0.043),
  #            color = "grey", linetype = "dashed") +
  # geom_hline(data = subset(repeated_measures_, tag_type == "GPS"), aes(yintercept = sum(GPS, harness, 4 * colour_band, metal_band) / 0.043),
  #            color = "grey", linetype = "dashed")

# ggplot(data = repeated_measures_) + 
#   geom_line(aes(x = x_line, y = weight, group = ring), color = "grey40", alpha = 0.5) + 
#   geom_jitter(size = 6, aes(x = x_point, y = weight, fill = tag_type, shape = measure), 
#               shape = 21, color = "grey40", alpha = 0.75, width = 0.075) +
#   scale_shape_manual(values = c(21, 24)) +
#   scale_fill_manual(values = custom_colors) +
#   facet_grid(~ tag_type, labeller = as_labeller(bdot_treatment_group_facets)) +
#   theme(legend.position = "none",
#         text = element_text(family = "lato"),
#         axis.title = element_text(size = 11, colour = "grey40"),
#         axis.ticks = element_blank(),
#         # axis.ticks.length = unit(0.1, "cm"),
#         axis.text = element_text(size = 10, colour = "grey40"),
#         axis.title.y = element_text(size = 12),
#         axis.text.y = element_text(size = 10),
#         plot.margin = unit(c(0.2,0.2,0.2,0.2), "cm"),
#         panel.background = element_rect(fill = 'transparent', color = NA),
#         plot.background = element_rect(fill = 'transparent', color = NA), 
#         strip.background = element_rect(fill = 'transparent', color = NA),
#         strip.text = element_text(size = 13, colour = "grey40"),
#         panel.grid.major.y = element_line(size = 0.25, lineend = "round", colour = "grey90"),
#         panel.grid.minor.y = element_line(size = 0.25, lineend = "round", colour = "grey90")) +
#   scale_x_continuous(limits = c(0.8, 2.2), breaks = c(1, 2), labels = c("first", "second")) +
#   # scale_y_continuous(limits = c(43, 73)) +
#   geom_hline(data = subset(repeated_measures_, tag_type == "PTT"), aes(yintercept = sum(PTT, harness, 4 * colour_band, metal_band) / 0.043),
#              color = "grey", linetype = "dashed") +
#   geom_hline(data = subset(repeated_measures_, tag_type == "GPS"), aes(yintercept = sum(GPS, harness, 4 * colour_band, metal_band) / 0.043),
#              color = "grey", linetype = "dashed") +
#   # geom_hline(yintercept = sum(GPS, harness, 4 * colour_band, metal_band) / 0.043,
#   #            color = "grey", linetype = "dashed") +
#   xlab("capture event") +
#   ylab("raw body mass (g)")

```

### Percentage of mass model
```{r}
#### percentage of weight ----
repeated_measures__ <- 
  repeated_measures %>%
  mutate(perc_burden = ifelse(tag_type == "control", sum(4 * colour_band, metal_band) / weight,
                              ifelse(tag_type == "PTT", sum(PTT, harness, 4 * colour_band, metal_band) / weight, 
                                     sum(GPS, harness, 4 * colour_band, metal_band) / weight)) * 100) %>% 
  arrange(ring, date) %>% 
  mutate(perc_burden = first(perc_burden),
         delta_smi_wing = first(smi_wing) - last(smi_wing),
         n_obs = n()) %>% 
  ungroup() %>% 
  filter(n_obs > 1) %>% 
  dplyr::select(ring, tag_type, delta_smi_wing, perc_burden) %>% 
  distinct()

repeated_measures__ %>% 
  group_by(tag_type) %>% 
  dplyr::summarise(max_ = max(perc_burden),
                   min_ = min(perc_burden),
                   mean_ = mean(perc_burden))

burden_smi_wing_lmer <- 
  lm(delta_smi_wing ~ perc_burden, 
       data = repeated_measures__)

# Derive confidence intervals of effect sizes from parametric bootstrapping
tidy_burden_smi_wing_lmer <-
  tidy(burden_smi_wing_lmer, conf.int = TRUE, conf.method = "boot", nsim = 1000)

# run rptR to obtain repeatabilities of random effects
rpt_burden_smi_wing_lmer <-
  rpt(smi_wing ~ perc_burden * measure + (1 | ring),
      grname = c("ring", "Fixed"),
      data = repeated_measures__,
      datatype = "Gaussian",
      nboot = 1000, npermut = 1000, ratio = TRUE,
      adjusted = TRUE, ncores = 4, parallel = TRUE)

# run partR2 on each model to obtain marginal R2, parameter estimates, and beta
# weights
R2m_burden_smi_wing_lmer <-
  partR2(burden_smi_wing_lmer,
         partvars = c("perc_burden",
                      "measure"),
         R2_type = "marginal",
         nboot = 1000,
         CI = 0.95,
         max_level = 1)

R2c_burden_smi_wing_lmer <-
  partR2(burden_smi_wing_lmer,
         partvars = c("perc_burden",
                      "measure"),
         R2_type = "conditional",
         nboot = 1000,
         CI = 0.95,
         max_level = 1)

stats_burden_smi_wing_lmer <-
  list(mod = burden_smi_wing_lmer,
       tidy = tidy_burden_smi_wing_lmer,
       rptR = rpt_burden_smi_wing_lmer,
       partR2m = R2m_burden_smi_wing_lmer,
       partR2c = R2c_burden_smi_wing_lmer,
       data = repeated_measures__)

summary(glht(burden_smi_wing_lmer))

#### Table of effect sizes ----
# Retrieve sample sizes
sample_sizes <-
  stats_burden_smi_wing_lmer$data %>%
  ungroup() %>%
  summarise(Individual = n_distinct(ring),
            Observations = nrow(.))

sample_sizes <-
  as.data.frame(t(as.data.frame(sample_sizes))) %>%
  rownames_to_column("term") %>%
  rename(estimate = V1) %>%
  mutate(stat = "n")

# clean model component names
mod_comp_names <-
  data.frame(comp_name = c("Initial SMI (g; baseline intercept))",
                           "Burden of attachments (% of body mass)",
                           "\u0394 SMI (g)",
                           "Additional \u0394 SMI (g) given attachment %",
                           "Total Marginal \U1D479\U00B2",
                           "Tag type",
                           "Measurement sequence",
                           "Total Conditional \U1D479\U00B2",
                           "Individual",
                           "Residual",
                           "Individual",
                           "Residual",
                           "Individuals",
                           "Observations"))

# Fixed effect sizes (non-standardized)
fixefTable <-
  stats_burden_smi_wing_lmer$tidy %>%
  dplyr::filter(effect == "fixed") %>%
  dplyr::select(term, estimate, conf.low, conf.high) %>%
  as.data.frame() %>%
  mutate(stat = "fixed")

# Fixed effect sizes (standardized)
fixef_bw_Table <-
  stats_burden_smi_wing_lmer$partR2m$BW %>%
  as.data.frame() %>%
  mutate(stat = "fixed_bw") %>%
  rename(conf.low = CI_lower,
         conf.high = CI_upper)

# Semi-partial R2 estimates
R2Table <-
  bind_rows(stats_burden_smi_wing_lmer$partR2m$R2,
            stats_burden_smi_wing_lmer$partR2c$R2[1,]) %>%
  dplyr::select(term, estimate, CI_lower, CI_upper) %>%
  as.data.frame() %>%
  mutate(stat = "partR2") %>%
  rename(conf.low = CI_lower,
         conf.high = CI_upper)

# Random effects variances
ranefTable <-
  stats_burden_smi_wing_lmer$tidy %>%
  dplyr::filter(effect == "ran_pars") %>%
  dplyr::select(group, estimate, conf.low, conf.high) %>%
  as.data.frame() %>%
  mutate(stat = "rand") %>%
  rename(term = group) %>%
  mutate(estimate = estimate^2,
         conf.high = conf.high^2,
         conf.low = conf.low^2)

# Adjusted repeatabilities
coefRptTable <-
  stats_burden_smi_wing_lmer$rptR$R_boot %>%
  dplyr::select(-Fixed) %>%
  mutate(residual = 1 - rowSums(.)) %>%
  apply(., 2,
        function(x) c(mean (x), quantile (x, prob = c(0.025, 0.975)))) %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("term") %>%
  rename(estimate = V1,
         conf.low = `2.5%`,
         conf.high = `97.5%`) %>%
  mutate(stat = "RptR")

# Store all parameters into a single table and clean it up
allCoefs_mod <-
  bind_rows(fixefTable[1,], 
            fixef_bw_Table,
            R2Table,
            ranefTable,
            coefRptTable,
            sample_sizes) %>%
  bind_cols(.,
            mod_comp_names) %>%
  mutate(coefString = ifelse(!is.na(conf.low),
                             paste0("[",
                                    round(conf.low, 2), ", ",
                                    round(conf.high, 2), "]"),
                             NA),
         effect = c(rep("Fixed effects \U1D6FD (standardized)", nrow(fixefTable[1,])),
                    rep("Fixed effects \U1D6FD (standardized)", nrow(fixef_bw_Table)),
                    rep("Partitioned \U1D479\U00B2", nrow(R2Table)),
                    rep("Random effects \U1D70E\U00B2", nrow(ranefTable)),
                    rep("Adjusted repeatability \U1D45F", nrow(coefRptTable)),
                    rep("Sample sizes \U1D45B", nrow(sample_sizes)))) %>%
  dplyr::select(effect, everything())

# draw gt table
smi_wing_lmer_seq_table <-
  allCoefs_mod %>%
  dplyr::select(effect, comp_name, estimate, coefString) %>%
  gt(rowname_col = "row",
     groupname_col = "effect") %>%
  cols_label(comp_name = html("<i> </i>"),
             estimate = "Mean estimate",
             coefString = "95% confidence interval") %>%
  fmt_number(columns = c(estimate),
             rows = 1:12,
             decimals = 2,
             use_seps = FALSE) %>%
  fmt_number(columns = c(estimate),
             rows = 13:14,
             decimals = 0,
             use_seps = FALSE) %>%
  sub_missing(columns = 1:4,
              missing_text = "") %>%
  cols_align(align = "left",
             columns = c(comp_name)) %>%
  tab_options(row_group.font.weight = "bold",
              row_group.background.color = brewer.pal(9,"Greys")[3],
              table.font.size = 12,
              data_row.padding = 3,
              row_group.padding = 4,
              summary_row.padding = 2,
              column_labels.font.size = 14,
              row_group.font.size = 12,
              table.width = pct(75))

smi_wing_lmer_seq_table

ggplot(repeated_measures__, 
       aes(x = perc_burden, y = delta_smi_wing)) + 
  geom_point() + 
  labs(x = "percent body wieght of attachments (%)", y = "\u0394 scaled mass index (g)") + 
  theme_minimal()
```


# Breeding status and outcome
### data import and wrangle
```{r}
# Function to extract the required characters
extract_and_merge <- function(text) {
  # Extract part before and after "|"
  parts <- str_split(text, "\\|", simplify = TRUE)
  part1 <- parts[1]
  part2 <- parts[2]
  
  # Extract the two characters to the left of the "|"
  left_chars <- str_sub(part1, -2, -1)
  
  # Extract the last two characters
  right_chars <- str_sub(part2, -2, -1)
  
  # Merge these four characters together
  paste0(left_chars, right_chars)
}

# Define a function to extract the desired patterns and ensure enough columns
extract_patterns <- function(text) {
  # Replace vertical bar '|' with an empty string
  text <- gsub("\\|", "", text)
  
  # Extract all 4 or 5-character long texts that start with R or r
  matches_r <- str_extract_all(text, "\\b[Rr]\\w{3,4}\\b")[[1]]
  
  # Extract UB, UN, UBF, UBM as standalone patterns
  matches_ub_un <- str_extract_all(text, "\\b[Uu][BbNnFfMm]\\b")[[1]]
  
  # Combine matches
  matches <- c(matches_r, matches_ub_un)
  
  # Ensure all matches are capitalized
  matches <- toupper(matches)
  
  # Ensure there are exactly two columns, filling with NA if necessary
  result <- c(matches, rep(NA, 2 - length(matches)))
  
  # Return the result as a named vector
  return(setNames(result, c("parent1", "parent2")))
}

# Apply the function to the dataframe
all_caps_KK <- 
  readRDS("data/all_caps_KK.rds") %>% 
  filter(year(date) > 2020) %>% 
  filter(ring != "CP16458") %>% 
  filter(ring != "CP16457") %>% 
  filter(ring != "CP16606")

all_caps_KK$parent <- 
  sapply(all_caps_KK$code, extract_and_merge) 

first_caps <- 
  all_caps_KK %>% 
  group_by(parent) %>%
  slice_min(order_by = date, n = 1) %>% 
  dplyr::select(parent, date, time, tag_type, treatment_group)
  
# import wrangle Ted and Ailsa's breeding records (i.e., the raw nest and brood visits)
# 2021
breeding_data_2021 <- 
  read_excel(here("data/Kaikoura_Dotterel_2021_Feb2022_upd_Nov22_Locations.xlsx"), 
                     sheet = "Kaikoura_NestVisit2021_1", 
                     col_types = "text") %>%
  mutate(visit_date_ = as.POSIXct(as.numeric(`Visit Date`) * 86400, origin = "1899-12-30", tz = "UTC")) %>% 
  mutate(visit_date_nz = with_tz(visit_date_, tzone = "Pacific/Auckland")) %>% 
  mutate(date = as.Date(visit_date_nz)) %>% 
  dplyr::select(OBJECTID, NestID, date, `Nest Status`, `Egg count`, `Number Hatched`, Notes, `Number Fledged`, `Number of chicks seen`) %>% 
  rename(nest_fate = `Nest Status`,
         eggs = `Egg count`,
         hatched = `Number Hatched`,
         fledged = `Number Fledged`,
         chicks = `Number of chicks seen`)

extracted_parents <- t(sapply(breeding_data_2021$NestID, extract_patterns))

breeding_data_2021 <-
  bind_cols(breeding_data_2021, extracted_parents) %>% 
  dplyr::select(-parent2) %>% 
  rename(parent = parent1) %>% 
  bind_rows(bind_cols(breeding_data_2021, extracted_parents) %>% 
              dplyr::select(-parent1) %>% 
              rename(parent = parent2)) %>% 
  filter(!is.na(parent)) %>% 
  mutate(state = ifelse(!is.na(Notes) & str_detect(tolower(Notes), "aband"), "aband", 
                        ifelse(((!is.na(hatched) & !is.na(chicks)) & (as.numeric(hatched) > 0 | as.numeric(chicks) > 0)) | 
                                 nest_fate == "Finished", "brood",
                               ifelse(nest_fate == "Failed", "fail", 
                                      ifelse((!is.na(eggs) & as.numeric(eggs > 0)) | nest_fate == "Occupied", "incub", "XXX"))))) %>% 
  mutate(state = ifelse(state == "brood" & as.numeric(fledged) > 0, "fledge", state)) %>% 
  right_join(., first_caps, by = "parent") %>% 
  filter(!is.na(date.x)) %>% arrange(NestID, date.x) %>% 
  filter(date.x >= date.y) %>% 
  mutate(nest_id = sub("^([^[:space:]]+).*", "\\1", NestID)) %>% 
  dplyr::select(-c(date.y, time)) %>% 
  rename(date = date.x) %>% 
  mutate(state = factor(state, levels = c("fledge", "fail", "aband", "brood", "incub")))

## 2022
breeding_data_2022 <-
  read_excel(here("data/Kaikoura_Dotterel_Jan23_upd.xlsx"), 
                     sheet = "Kaikoura_NestVisit_1", 
                     col_types = "text") %>%
  mutate(visit_date_ = as.POSIXct(as.numeric(`Visit Date`) * 86400, origin = "1899-12-30", tz = "UTC")) %>% 
  mutate(visit_date_nz = with_tz(visit_date_, tzone = "Pacific/Auckland")) %>% 
  mutate(date = as.Date(visit_date_nz)) %>% 
  dplyr::select(OBJECTID, NestID, date, `Nest Status`, `Egg count`, `Number Hatched`, Notes, `Number Fledged`, `Number of chicks seen`) %>% 
  rename(nest_fate = `Nest Status`,
         eggs = `Egg count`,
         hatched = `Number Hatched`,
         fledged = `Number Fledged`,
         chicks = `Number of chicks seen`)

extracted_parents <- t(sapply(breeding_data_2022$NestID, extract_patterns))

breeding_data_2022 <-
  bind_cols(breeding_data_2022, extracted_parents) %>% 
  dplyr::select(-parent2) %>% 
  rename(parent = parent1) %>% 
  bind_rows(bind_cols(breeding_data_2022, extracted_parents) %>% 
              dplyr::select(-parent1) %>% 
              rename(parent = parent2)) %>% 
  filter(!is.na(parent)) %>% 
  mutate(state = ifelse(!is.na(Notes) & str_detect(tolower(Notes), "aband"), "aband", 
                        ifelse(((!is.na(hatched) & !is.na(chicks)) & (as.numeric(hatched) > 0 | as.numeric(chicks) > 0)) | 
                                 nest_fate == "Finished", "brood",
                               ifelse(nest_fate == "Failed", "fail", 
                                      ifelse((!is.na(eggs) & as.numeric(eggs > 0)) | nest_fate == "Occupied", "incub", "XXX"))))) %>% 
  mutate(state = ifelse(state == "brood" & as.numeric(fledged) > 0, "fledge", state)) %>% 
  right_join(., first_caps, by = "parent") %>% 
  filter(!is.na(date.x)) %>% arrange(NestID, date.x) %>% 
  filter(date.x >= date.y) %>% 
  mutate(nest_id = sub("^([^[:space:]]+).*", "\\1", NestID)) %>% 
  dplyr::select(-c(date.y, time)) %>% 
  rename(date = date.x) %>% 
  mutate(state = factor(state, levels = c("fledge", "fail", "aband", "brood", "incub")))

## 2023
breeding_data_2023 <-
  read_excel(here("data/Kaikoura_Dotterel_Feb2024_upd.xlsx"), 
                     sheet = "Kaikoura_NestVisit_1", 
                     col_types = "text") %>%
  mutate(visit_date_ = as.POSIXct(as.numeric(`Visit Date`) * 86400, origin = "1899-12-30", tz = "UTC")) %>% 
  mutate(visit_date_nz = with_tz(visit_date_, tzone = "Pacific/Auckland")) %>% 
  mutate(date = as.Date(visit_date_nz)) %>% 
  dplyr::select(OBJECTID, NestID, date, `Nest Status`, `Egg count`, `Number Hatched`, Notes, `Number Fledged`, `Number of chicks seen`) %>% 
  rename(nest_fate = `Nest Status`,
         eggs = `Egg count`,
         hatched = `Number Hatched`,
         fledged = `Number Fledged`,
         chicks = `Number of chicks seen`)

extracted_parents <- t(sapply(breeding_data_2023$NestID, extract_patterns))

breeding_data_2023 <-
  bind_cols(breeding_data_2023, extracted_parents) %>% 
  dplyr::select(-parent2) %>% 
  rename(parent = parent1) %>% 
  bind_rows(bind_cols(breeding_data_2023, extracted_parents) %>% 
              dplyr::select(-parent1) %>% 
              rename(parent = parent2)) %>% 
  filter(!is.na(parent)) %>% 
  mutate(state = ifelse(!is.na(Notes) & str_detect(tolower(Notes), "aband"), "aband", 
                        ifelse(((!is.na(hatched) & !is.na(chicks)) & (as.numeric(hatched) > 0 | as.numeric(chicks) > 0)) | 
                                 nest_fate == "Finished", "brood",
                               ifelse(nest_fate == "Failed", "fail", 
                                      ifelse((!is.na(eggs) & as.numeric(eggs > 0)) | nest_fate == "Occupied", "incub", "XXX"))))) %>% 
  mutate(state = ifelse(state == "brood" & as.numeric(fledged) > 0, "fledge", state)) %>% 
  right_join(., first_caps, by = "parent") %>% 
  filter(!is.na(date.x)) %>% arrange(NestID, date.x) %>% 
  filter(date.x >= date.y) %>% 
  mutate(nest_id = sub("^([^[:space:]]+).*", "\\1", NestID)) %>% 
  dplyr::select(-c(date.y, time)) %>% 
  rename(date = date.x) %>% 
  mutate(state = factor(state, levels = c("fledge", "fail", "aband", "brood", "incub")))

tag_date_info <-
  read_excel(here("data/tag_deploy_retrieve_dates.xlsx"), 
                     col_types = "text") %>%
  mutate(recapture_date = as.Date(as.POSIXct(as.numeric(recapture_date) * 86400, origin = "1899-12-30", tz = "UTC")),
         last_argos_data = as.Date(as.POSIXct(as.numeric(last_argos_data) * 86400, origin = "1899-12-30", tz = "UTC")),
         deployment_date = as.Date(as.POSIXct(as.numeric(deployment_date) * 86400, origin = "1899-12-30", tz = "UTC")))

# merge all breeding data and classify tag status based on deployment and removal times
nest_fates <-
  bind_rows(breeding_data_2021, breeding_data_2022, breeding_data_2023) %>%
  mutate(season = ifelse(month(date) < 7, year(date) - 1, year(date))) %>% 
  mutate(nest_id = paste(season, nest_id, sep = "_")) %>%
  mutate(state = as.character(state)) %>% 
  mutate(state = ifelse(is.na(state) & !is.na(eggs) & eggs > 0, "incub", state)) %>% 
  mutate(state = ifelse(is.na(state) & grepl("chick", Notes), "brood", state)) %>% 
  mutate(state = factor(state, levels = c("fledge", "fail", "aband", "brood", "incub"))) %>% 
  filter(!is.na(state)) %>% 
  group_by(nest_id, parent, tag_type, season) %>%
  dplyr::summarise(state = min(as.numeric(state), na.rm = TRUE),
                   date = min(date, na.rm = TRUE)) %>% 
  mutate(state = ifelse(state == 1, "fledge", 
                        ifelse(state == 2, "fail",
                               ifelse(state == 3, "aband", 
                                      ifelse(state == 4, "brood", 
                                             ifelse(state == 5, "unkn", "xxx")))))) %>% 
  ungroup() %>%
  mutate(state = factor(state, levels = c("fledge", "fail", "aband", "brood", "unkn")),
         tag_type = factor(tag_type),
         parent = factor(parent),
         season = factor(season)) %>% 
  left_join(., tag_date_info %>% dplyr::select(-tag_type), by = "parent") %>% 
  mutate(tag_type = as.character(tag_type)) %>%
  mutate(tag_type = ifelse(!is.na(deployment_date) & !is.na(recapture_date) & (date < deployment_date | date >= recapture_date), 
                           "control", tag_type)) %>% 
  mutate(tag_type = as.factor(tag_type)) %>% 
  dplyr::select(-c("nickname", "deployment_date", "recapture_date", "comment", "last_argos_data")) %>%
  mutate(state = factor(state, levels = c("aband", "fail", "brood", "fledge", "unkn")),
         tag_type = factor(tag_type, levels = c("control", "GPS", "PTT")))

# bind_rows(breeding_data_2021, breeding_data_2022, breeding_data_2023) %>%
#   mutate(season = ifelse(month(date) < 7, year(date) - 1, year(date))) %>% 
#   # dplyr::select(nest_id, nest_fate, fledged, season, tag_type, parent) %>% 
#   left_join(., tag_date_info %>% dplyr::select(-tag_type), by = "parent") %>% 
#   mutate(tag_type = as.character(tag_type)) %>%
#   mutate(tag_type = ifelse(!is.na(deployment_date) & !is.na(recapture_date) & (date < deployment_date | date >= recapture_date), 
#                            "control", tag_type)) %>% 
#   filter(fledged > 0 & !is.na(nest_fate)) %>% 
#   distinct() %>% 
#   group_by(nest_id) %>% 
#   slice_tail(n = 1) %>% 
#   arrange(date)
#   mutate(fledged = as.numeric(fledged)) %>% 
#   group_by(season, tag_type) %>% 
#   summarise(total_fledged = sum(fledged))

nest_fates

nest_fates %>% 
  group_by(tag_type) %>% 
  dplyr::summarise(n_nests = n_distinct(nest_id))

nest_fates %>% 
  group_by(tag_type) %>% 
  dplyr::summarise(n_ind = n_distinct(parent))

tag_date_info %>% 
  filter(tag_type == "PTT") %>% 
  pull(parent) %>% unique() %>% sort()

nest_fates %>% 
  filter(tag_type == "PTT") %>% 
  pull(parent) %>% unique() %>% sort()

bdot_ch %>% 
  filter(parent %in% c("RBOG", "RBWO"))
# "RBOG" and "RBWO"
```

### modelling
```{r}
# ## get all parameters and parameters classes to define priors on
# prior <- 
#    default_prior(state ~ tag_type + (1 | season) + (1 | parent),
#                  data = nest_fates, family = categorical(link = "logit"))
# 
# # Check the prior names to ensure we set them correctly
# default_priors <- get_prior(
#   state ~ tag_type + (1 | season) + (1 | parent),
#   data = nest_fates,
#   family = categorical(link = "logit")
# )
# 
# # Print the default priors to inspect the model parameters
# print(default_priors)
# 
# # Set the correct priors based on the parameter names from get_prior()
# priors <-
#   default_priors %>% 
#   mutate(prior = ifelse(class == "b", "normal(0, 5)", prior))

# Fit the mixed-effects multinomial logistic regression model with informative priors
model_brm <- brm(
  state ~ tag_type + (1 | season) + (1 | parent),
  data = nest_fates,
  family = categorical(link = "logit"),
  chains = 4,
  iter = 4000,  # Increased number of iterations
  control = list(adapt_delta = 0.99, max_treedepth = 15)  # Adjusted control parameters for better convergence
  # prior = priors  # Use the defined priors
)

summary(model_brm)

# Extract the posterior samples
post_samples <- posterior_samples(model_brm)

# Extract coefficients for tag_type
tag_type_coeffs <- post_samples %>%
  dplyr::select(matches("b_mu.+_tag_type"))

# Summarize the coefficients
tag_type_summary <- posterior_summary(tag_type_coeffs)
print(tag_type_summary)

# Calculate odds ratios
odds_ratios <- exp(tag_type_summary[, c("Estimate", "Q2.5", "Q97.5")])
print(odds_ratios)

# Pairwise comparison between GPS and PTT for the 'fail' state
hypothesis(model_brm, "mufail_tag_typeGPS - mufail_tag_typePTT > 0")

# Predicted probabilities for 'tag_type'
conditional_effects_plot <- 
  conditional_effects(model_brm, effects = "tag_type", 
                      categorical = TRUE)
plot(conditional_effects_plot)

# Coefficient plot for fixed effects
mcmc_plot(model_brm, pars = "^b_")

# Generate predictions with interval set to "prediction"
predictions_tag_type <- 
  ggpredict(model_brm, 
            terms = "tag_type", 
            type = "fixed", 
            # interval = "prediction",
            bias_correction = TRUE
            )

plot(predictions_tag_type) +
  labs(title = "Effect of Tag Type on Predicted State Probabilities",
       x = "Tag Type", y = "Predicted Probability") +
  theme_minimal()

predictions_tag_type_ <- 
  predictions_tag_type %>% 
  as.data.frame() %>% 
  mutate(response.level = factor(response.level, levels = c("brood", "fledge", "fail", "aband", "unkn")))

# Assuming 'nest_fates' is your data frame
# Calculate the sample sizes
sample_sizes <- nest_fates %>%
  group_by(tag_type, state) %>%
  summarise(n = n()) %>%
  ungroup() %>% 
  rename(x = tag_type, 
         response.level = state) %>% 
  bind_rows(., data.frame(x = c("GPS", "GPS", "PTT"), response.level = c("fledge", "aband", "unkn"), n = c(0, 0, 0)))

# Merge the sample sizes with your predictions
predictions_tag_type_ <- predictions_tag_type_ %>%
  left_join(sample_sizes, by = c("x", "response.level"))

custom_colors_ <- brewer.pal(9, "Set1")[c(9, 2, 3)]

# tag_type_breeding_fate_plot <-
  ggplot(data = predictions_tag_type_) +
  geom_errorbar(aes(x = x, y = predicted, ymin = conf.low, ymax = conf.high, color = x), 
               size = 0.3, linetype = "solid", width = 0.1) +
  geom_point(aes(x = x, y = predicted, fill = x), shape = 21, size = 6) +
  scale_fill_manual(values = custom_colors) +
  scale_color_manual(values = custom_colors_) +
  geom_text(aes(label = n, y = 1, x = x),  # Adjust 'y' to place the text appropriately
            size = 3, color = "black", vjust = 0) +  # Adjust 'size' and 'vjust' as needed +
  theme_bw() + 
  dipper_theme +
  ylab("Probability (Â± 95% CI)") +
  scale_y_continuous(limits = c(0, 1)) +
  # scale_color_brewer(palette = "Set1") +
  facet_grid(~ response.level, labeller = as_labeller(bdot_breeding_fate_facets))

# Calculate sample sizes
sample_sizes <- nest_fates %>%
  group_by(tag_type, state) %>%
  summarise(n = n(), .groups = 'drop')

# Create a data frame for the annotations
annotation_df <- sample_sizes %>%
  mutate(
    x = tag_type,
    response.level = state,
    label = paste0("n = ", n)
  ) %>% 
  bind_rows(., data.frame(tag_type = c("GPS", "PTT"),
                          state = c("aband", "unkn"),
                          n = c(0, 0),
                          x = c("GPS", "PTT"),
                          response.level = c("aband", "unkn"),
                          label = c("n = 0", "n = 0")))
facet_labels <- c(
  "aband" = "abandoned",
  "brood" = "hatched",
  "fail" = "failed",
  "fledge" = "fledged",
  "unkn" = "unknown"
)

# Facet the plot by 'state'
ggplot(as.data.frame(predictions_tag_type), aes(x = x, y = predicted, color = x)) +
  geom_point() +
  # geom_errorbarh(aes(xmin = Q2.5, xmax = Q97.5), height = 0.2)
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), alpha = 1, width = 0) +
  geom_text(data = annotation_df, aes(x = x, y = -0.1, label = label),
            color = "black", size = 3, position = position_nudge(y = -0.05)) +
  labs(title = "Effect of Tag Type on Predicted State Probabilities",
       x = "Tag Type", y = "Predicted Probability") +
  theme_minimal() +
  facet_wrap(~ response.level, scales = "fixed", labeller = labeller(response.level = facet_labels), nrow = 1) +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.position = "none")
```

# Apparent survival
```{r}
# install.packages("BaSTA")
# library(BaSTA)
# 
# dat %>% 
#   group_by(season, rings_comb) %>% 
#   summarise(n_obs = n()) %>% 
#   mutate(seen = 1) %>% 
#   dplyr::select(-n_obs) %>% 
#   CensusToCaptHist(ID = .$rings_comb, 
#                    d = .$season,
#                    timeInt = "Y") %>% 
#   write.csv(., 
#             "/Users/luketheduke2/ownCloud/kemp_projects/bdot/R_projects/bdot_ethics/data/mark_recapture_df.csv", row.names = FALSE)

bdot_ch <- 
  read.csv("/Users/leberhart/ownCloud/kemp_projects/bdot/R_projects/bdot_ethics/data/mark_recapture_df.csv") %>% 
  rename(parent = ID) %>% 
  left_join(., tag_date_info %>% dplyr::select(parent, tag_type, deployment_date, recapture_date), by = "parent") %>% 
  mutate(tag_type = str_sub(tag_type, 1, 1)) %>% 
  mutate(deployment_date = ifelse(!is.na(deployment_date), year(deployment_date), NA),
         recapture_date = ifelse(!is.na(recapture_date), year(recapture_date), NA)) %>% 
  mutate(X2021 = ifelse(X2021 == 1, "C", "0"),
         X2022 = ifelse(X2022 == 1, "C", '0'),
         X2023 = ifelse(X2023 == 1, "C", "0")) %>% 
  mutate(X2021 = ifelse(X2021 == "0", "0",
                        ifelse(is.na(deployment_date), "C",
                               ifelse(deployment_date == 2021, tag_type, "C"))),
         X2022 = ifelse(X2022 == "0", "0",
                        ifelse(is.na(deployment_date), "C",
                               ifelse(deployment_date == 2022, tag_type, 
                                      ifelse(!is.na(recapture_date), tag_type, "C")))),
         X2023 = ifelse(X2023 == "0", "0",
                        ifelse(is.na(deployment_date), "C",
                               ifelse(deployment_date == 2022, tag_type, 
                                      ifelse(recapture_date == 2023, tag_type,
                                             ifelse(is.na(recapture_date), tag_type, "C")))))) %>% 
  mutate(X2022 = ifelse(parent == "RBRL", "P", X2022),
         X2023 = ifelse(parent == "RBRL", "P", X2023)) %>% 
  mutate(X2022 = ifelse(parent == "RBWO", "P", X2022)) %>% 
  mutate(X2022 = ifelse(parent == "RRBR", "G", X2022)) %>% 
  mutate(X2022 = ifelse(parent == "RRRG", "P", X2022)) %>% 
  arrange(tag_type) %>% 
  dplyr::select(-c(tag_type, deployment_date, recapture_date))

bdot_ch <- 
  data.frame(ch = apply(bdot_ch[, 2:4], 1, paste, collapse = ""),
             freq = 1)

bdot_ch %>% 
  group_by(ch) %>% 
  summarise(n())
```


```{r}
# Specify the states and create the dataframe for RMark
bdot_processed <- process.data(bdot_ch, model = "Multistrata", groups = NULL)


bdot_ddl <- make.design.data(bdot_processed)

# bdot_ddl$Psi$fix=NA
# bdot_ddl$Psi$fix[bdot_ddl$Psi$stratum=="G" & bdot_ddl$Psi$tostratum=="P"]=0
# bdot_ddl$Psi$fix[bdot_ddl$Psi$stratum=="P" & bdot_ddl$Psi$tostratum=="G"]=0
# bdot_ddl$Psi
# summary(mark(dp,ddl,output=FALSE),show.fixed=TRUE)

table(bdot_ddl$Psi[,c("stratum","tostratum")])

# Define parameter formulas
S.model <- list(formula = ~ stratum)  # Survival depends on the state
p.model <- list(formula = ~ stratum)  # Detection probability depends on the state
Psi.model.stratum <- list(formula = ~ -1+stratum)  
Psi.model.stratumto <- list(formula = ~ -1+stratum:tostratum) 
Psi.model.stratumtotime <- list(formula = ~ -1+stratum:tostratum:time)  # Transition probabilities depend on the state and destination state

model.list <- create.model.list("Multistrata") 
bdot.results <- mark.wrapper(model.list, data = bdot_processed, ddl = bdot_ddl)
bdot.results$S.model.p.model.Psi.model.stratumtotime$results$real

# extract and format the transformed parameter estimates
bdot_estimates <-
  bdot.results$S.model.p.model.Psi.model.stratumtotime$results$real %>% 
  bind_cols(data.frame(str_split_fixed(rownames(.), " ", 
                                       n = 5)), .) %>% 
  dplyr::mutate(tag_type = as.factor(ifelse(unlist(str_extract_all(X2,"[CGP]")) == "C", "control",
                                            ifelse(unlist(str_extract_all(X2,"[CGP]")) == "G", "GPS", "PTT"))),
                parameter = as.factor(ifelse(X1 == "S", "Phi",
                                            ifelse(X1 == "p", "p", "Psi"))),
                transition = ifelse(X1 == "Psi", paste0(str_sub(X2, 2, 2), X3), NA),
                year = ifelse(X1 == "Psi", ifelse(str_sub(X5, 10, 11) == "t1", 2021, 2022), NA)) %>% 
  dplyr::select(parameter, tag_type, transition, year, estimate, lcl, ucl) %>% 
  `rownames<-`( NULL )
  
#### Plotting ####
# first setup the plotting theme
dipper_theme <- 
  theme(text = element_text(family = "Franklin Gothic Book"),
        legend.position = "none",
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10),
        axis.title.y = element_text(size = 10,margin = margin(t = 0, r = 10, b = 0, l = 0)),
        axis.text.y  = element_text(size = 9),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.ticks.y = element_line(size = 0.2, colour = "grey40"),
        axis.ticks.length = unit(0.1, "cm"),
        axis.ticks.x = element_line(size = 0.2, colour = "grey40"),
        plot.margin = unit(c(0.2, 0.2, 0.2, 0.2), "cm"),
        panel.spacing = unit(0.3, "lines"),
        strip.background = element_blank(),
        strip.text = element_text(size = 12),
        panel.border = element_rect(linetype = "solid", colour = "grey"),
        panel.background = element_rect(linetype = "solid", fill = "white"))


# get sample sizes of individuals used to estimate age-specific rates
bdot_ch %>% 
  mutate(tag_type = ifelse(str_detect(ch, "P"), "PTT",
                           ifelse(str_detect(ch, "G"), "GPS",
                                  ifelse(str_detect(ch, "C"), "control", NA)))) %>% 
  group_by(tag_type) %>% 
  summarise(N = n())

bdot_estimates %>% as.tibble() %>% print(n = nrow(.))

tag_type_surv_plot <- 
  ggplot(data = filter(bdot_estimates, parameter == "Phi"),
         aes(x = tag_type, y = estimate, color = tag_type)) +
  geom_errorbar(aes(ymin = lcl, ymax = ucl), 
               size = 0.3, linetype = "solid", width = 0.1) +
  geom_point(size = 3) +
  theme_bw() + 
  dipper_theme +
  ylab("Apparent survival (Â± 95% CI)") +
  scale_y_continuous(limits = c(0, 1)) +
  scale_color_brewer(palette = "Set1") +
  annotate(geom = "text", y = 0.6, x = 1, angle = 0,
           label = "N = 74", 
           color = "grey30", size = 2.5, fontface = 'italic') +
  annotate(geom = "text", y = 0.45, x = 2, angle = 0,
           label = "N = 10", 
           color = "grey30", size = 2.5, fontface = 'italic') +
  annotate(geom = "text", y = 0.45, x = 3, angle = 0,
           label = "N = 10", 
           color = "grey30", size = 2.5, fontface = 'italic')

tag_type_p_plot <- 
  ggplot(data = filter(bdot_estimates, parameter == "p"),
         aes(x = tag_type, y = estimate, color = tag_type)) +
  geom_errorbar(aes(ymin = lcl, ymax = ucl), 
               size = 0.3, linetype = "solid", width = 0.1) +
  geom_point(size = 3) +
  theme_bw() + 
  dipper_theme +
  ylab("Apparent survival (Â± 95% CI)") +
  scale_y_continuous(limits = c(0, 1)) +
  scale_color_brewer(palette = "Set1") +
  annotate(geom = "text", y = 0.6, x = 1, angle = 0,
           label = "N = 74", 
           color = "grey30", size = 2.5, fontface = 'italic') +
  annotate(geom = "text", y = 0.45, x = 2, angle = 0,
           label = "N = 10", 
           color = "grey30", size = 2.5, fontface = 'italic') +
  annotate(geom = "text", y = 0.45, x = 3, angle = 0,
           label = "N = 10", 
           color = "grey30", size = 2.5, fontface = 'italic')

tag_type_p_plot
```


```{r}
# dipper_df_ch_age_site %>% 
#   mutate(recuit = ifelse(str_detect(ch, "11") & age == "J", "yes", "no")) %>% 
#   group_by(site, age, recuit) %>% 
#   summarise(N = n())
# 
# Age_Site_Phi_plot <- 
#   ggplot(data = filter(estimates_age_site, parameter == "Phi"),
#          aes(x = site, y = estimate, color = age)) +
#   geom_errorbar(aes(ymin = lcl, ymax = ucl), position = position_dodge(1), 
#                 size = 0.3, linetype = "solid", width = 0.1) +
#   geom_point(size = 3, position = position_dodge(1)) +
#   theme_bw() + 
#   dipper_theme +
#   theme(legend.position = "top",
#         axis.title.y = element_blank(),
#         axis.text.y  = element_blank()) +
#   ylab("Apparent survival (Â± 95% CI)") +
#   scale_y_continuous(limits = c(0, 1)) +
#   scale_color_brewer(palette = "Dark2") +
#   annotate(geom = "text", y = 0.73, x = 0.75, angle = 0,
#            label = "N = 12", 
#            color = "grey30", size = 2.5, fontface = 'italic') +
#   annotate(geom = "text", y = 0.25, x = 1.25, angle = 0,
#            label = "N = 66", 
#            color = "grey30", size = 2.5, fontface = 'italic')  +
#   annotate(geom = "text", y = 0.8, x = 1.75, angle = 0,
#            label = "N = 33", 
#            color = "grey30", size = 2.5, fontface = 'italic') +
#   annotate(geom = "text", y = 0.33, x = 2.25, angle = 0,
#            label = "N = 93", 
#            color = "grey30", size = 2.5, fontface = 'italic')
# 
# Age_Site_p_plot <- 
#   ggplot(data = filter(estimates_age_site, parameter == "p"),
#          aes(x = site, y = estimate, color = age)) +
#   geom_errorbar(aes(ymin = lcl, ymax = ucl), position = position_dodge(1), 
#                 size = 0.3, linetype = "solid", width = 0.1) +
#   geom_point(size = 3, position = position_dodge(1)) +
#   theme_bw() + 
#   dipper_theme +
#   theme(legend.position = "top",
#         axis.title.y = element_blank(),
#         axis.text.y  = element_blank()) +
#   ylab("Apparent survival (Â± 95% CI)") +
#   scale_y_continuous(limits = c(0, 1)) +
#   scale_color_brewer(palette = "Dark2") +
#   annotate(geom = "text", y = 0.73, x = 0.75, angle = 0,
#            label = "N = 12", 
#            color = "grey30", size = 2.5, fontface = 'italic') +
#   annotate(geom = "text", y = 0.25, x = 1.25, angle = 0,
#            label = "N = 66", 
#            color = "grey30", size = 2.5, fontface = 'italic')  +
#   annotate(geom = "text", y = 0.8, x = 1.75, angle = 0,
#            label = "N = 33", 
#            color = "grey30", size = 2.5, fontface = 'italic') +
#   annotate(geom = "text", y = 0.33, x = 2.25, angle = 0,
#            label = "N = 93", 
#            color = "grey30", size = 2.5, fontface = 'italic')
# 
# # arrange multi-paneled plot
# Wurm_plot <-
#   Sex_Phi_plot + Age_Site_Phi_plot + 
#   plot_annotation(
#     title = 'CJS model of European Dippers (2017-2022)') + 
#   plot_layout(widths = c(1, 1.5))
# 
# # export plot to working directory
# ggsave(Wurm_plot,
#        filename = "figs/age_site_sex_dipper_survival_2017-2022.jpeg",
#        width = 5,
#        height = 4, 
#        units = "in")
# 
# #### Tabulation of results ####
# dipper_CJS_effect_size_table <- 
#   estimates_combined %>% 
#   mutate(structure = ifelse(parameter != "Phi" & str_detect(analysis, "sex"), "-", 
#                             ifelse(parameter == "p" & str_detect(analysis, "site"), as.character(age),
#                                    ifelse(is.na(sex) & parameter == "Phi", 
#                                           paste0(site, ", ", age), 
#                                           as.character(sex))))) %>% 
#   dplyr::select(parameter, structure, estimate, analysis, coefString) %>%
#   gt(groupname_col = "analysis") %>% 
#   cols_label(parameter = html("<i>Model</i>"),
#              estimate = "Mean estimate",
#              coefString = "95% confidence interval",
#              structure = html("<i>structure</i>")) %>% 
#   fmt_number(columns = vars(estimate),
#              rows = 1:9,
#              decimals = 2,
#              use_seps = FALSE) %>% 
#   cols_align(align = "right",
#              columns = vars(parameter)) %>% 
#   cols_align(align = "left",
#              columns = vars(structure)) %>% 
#   tab_options(row_group.font.weight = "bold",
#               row_group.background.color = brewer.pal(9,"Greys")[3],
#               table.font.size = 12,
#               data_row.padding = 3,
#               row_group.padding = 4,
#               summary_row.padding = 2,
#               column_labels.font.size = 14,
#               row_group.font.size = 12,
#               table.width = pct(50)) %>% 
#   tab_header(
#     title = "CJS model of European Dippers (2017 to 2022)",
#     subtitle = "Effect sizes"
#   )
# 
# dipper_CJS_effect_size_table %>%
#   gtsave("dipper_CJS_effect_size_table.png", path = "tables/")
# 
# dipper_CJS_betas_table <- 
#   betas_combined %>% 
#   dplyr::select(parameter, component, estimate, analysis, coefString) %>%
#   gt(groupname_col = "analysis") %>% 
#   cols_label(parameter = html("<i>Model</i>"),
#              estimate = "Mean estimate",
#              coefString = "95% confidence interval",
#              component = html("<i>structure</i>")) %>% 
#   fmt_number(columns = vars(estimate),
#              rows = 1:8,
#              decimals = 2,
#              use_seps = FALSE) %>% 
#   cols_align(align = "right",
#              columns = vars(parameter)) %>% 
#   cols_align(align = "left",
#              columns = vars(component)) %>% 
#   tab_options(row_group.font.weight = "bold",
#               row_group.background.color = brewer.pal(9,"Greys")[3],
#               table.font.size = 12,
#               data_row.padding = 3,
#               row_group.padding = 4,
#               summary_row.padding = 2,
#               column_labels.font.size = 14,
#               row_group.font.size = 12,
#               table.width = pct(50)) %>% 
#   tab_header(
#     title = "CJS model of European Dippers (2017 to 2022)",
#     subtitle = "Fixed effect coefficients"
#   )
# 
# 
# # Create the model
# ms_model <- mark(df_processed, model = "Multistrata", 
#                  model.parameters = list(S = S.model, p = p.model, Psi = Psi.model))
# 
# # Run the model
# ms_results <- summary(ms_model)
# 
# ms_results$beta
# 
# ms_results$beta[2, "estimate"] <- ms_results$beta[2, "estimate"] + ms_results$beta[1, "estimate"]
# ms_results$beta[3, "estimate"] <- ms_results$beta[3, "estimate"] + ms_results$beta[1, "estimate"]
# ms_results$beta[5, "estimate"] <- ms_results$beta[5, "estimate"] + ms_results$beta[4, "estimate"]
# ms_results$beta[6, "estimate"] <- ms_results$beta[6, "estimate"] + ms_results$beta[4, "estimate"]
# ms_results$beta[8, "estimate"] <- ms_results$beta[8, "estimate"] + ms_results$beta[7, "estimate"]
# ms_results$beta[9, "estimate"] <- ms_results$beta[9, "estimate"] + ms_results$beta[7, "estimate"]
# 
# ms_results$beta[2, "lcl"] <- ms_results$beta[2, "lcl"] + ms_results$beta[1, "lcl"]
# ms_results$beta[3, "lcl"] <- ms_results$beta[3, "lcl"] + ms_results$beta[1, "lcl"]
# ms_results$beta[5, "lcl"] <- ms_results$beta[5, "lcl"] + ms_results$beta[4, "lcl"]
# ms_results$beta[6, "lcl"] <- ms_results$beta[6, "lcl"] + ms_results$beta[4, "lcl"]
# ms_results$beta[8, "lcl"] <- ms_results$beta[8, "lcl"] + ms_results$beta[7, "lcl"]
# ms_results$beta[9, "lcl"] <- ms_results$beta[9, "lcl"] + ms_results$beta[7, "lcl"]
# 
# ms_results$beta[2, "ucl"] <- ms_results$beta[2, "ucl"] + ms_results$beta[1, "ucl"]
# ms_results$beta[3, "ucl"] <- ms_results$beta[3, "ucl"] + ms_results$beta[1, "ucl"]
# ms_results$beta[5, "ucl"] <- ms_results$beta[5, "ucl"] + ms_results$beta[4, "ucl"]
# ms_results$beta[6, "ucl"] <- ms_results$beta[6, "ucl"] + ms_results$beta[4, "ucl"]
# ms_results$beta[8, "ucl"] <- ms_results$beta[8, "ucl"] + ms_results$beta[7, "ucl"]
# ms_results$beta[9, "ucl"] <- ms_results$beta[9, "ucl"] + ms_results$beta[7, "ucl"]
# 
# ms_results$beta %>% 
#   mutate(estimate = logistic(estimate),
#          lcl = logistic(lcl),
#          ucl = logistic(ucl))
# 
# ms_results$reals$S$` Stratum:C`$pim
# ms_results$reals$S$` Stratum:G`$pim
# ms_results$reals$S$` Stratum:P`$pim
# 
# # Create a data frame with the covariate values for prediction
# new_data <- data.frame(stratum = factor(c("G", "P", "C")))
# 
# # Get predicted survival probabilities
# S_predictions <- covariate.predictions(ms_model, data = new_data, indices = NULL, parameter = "S")
# 
# # Get predicted detection probabilities
# p_predictions <- covariate.predictions(ms_model, data = new_data, indices = NULL, parameter = "p")
# 
# # Get predicted transition probabilities
# Psi_predictions <- covariate.predictions(ms_model, data = new_data, indices = NULL, parameter = "Psi")
# 
# # Display the results
# print(S_predictions)
# print(p_predictions)
# print(Psi_predictions)
# 
#   # Define the logistic function
# logistic <- function(x) {
#   1 / (1 + exp(-x))
# }
# 
# # Convert beta estimates to probabilities
# predicted_probabilities <- logistic(beta_estimates$estimate)
# # Display the results
# print(ms_results)

```


# Movements of tagged birds
```{r}
# function to read tagging data
import_plover_tag_spatial_fun <- 
  function(data_loc, tag_ID, projection,
           time_zone = "America/Mazatlan",
           tag_model, bird_ID, bird_sex, bird_code, 
           species, population, n_slice){
    
    if(tag_model == "nanoFix-mini")
    {
      # read data file and extract data
      Tag <- 
        read.table(sep = ",", skip = 5, file = data_loc) %>% 
        
        # assign column names
        `colnames<-` (c("day", "month", "year", "hour", "minute", "second", "unknown_col", 
                        "satellites", "latitude", "longitude", "elevation", 
                        "clock_offset", "accuracy_indicator", "battery")) %>% 
        
        mutate(
          # make a fix number column
          fix_number = str_pad(row.names(.), 2, pad = "0"),
          
          # make a timestamp column
          timestamp = paste(paste(year, month, 
                                  day, sep = "-"), 
                            paste(hour, minute, 
                                  second, sep = ":"), sep = " ")) %>% 
        mutate(
          # convert to a useable POSIX time/date string
          timestamp = as.POSIXct(strptime(as.character(timestamp), 
                                          format = "%y-%m-%d %H:%M:%S"), 
                                 tz = time_zone),
          
          # assign name of tag
          tag_ID = tag_ID,
          
          # make a simplified version of the time sting
          timestamp_simple = as.Date(str_sub(as.character(timestamp), 
                                             start = 1, end = 10), 
                                     format = "%Y-%m-%d")) %>% 
        
        # remove observations without a reliable location
        dplyr::filter(latitude != 0 & !is.na(latitude)) %>%
        
        # remove observations without a reliable location
        dplyr::filter(timestamp != 0 & !is.na(timestamp)) %>%
        
        # names() %>% 
        # as.data.frame()
        
        dplyr::select(tag_ID, timestamp_simple, fix_number, timestamp, 
                      satellites, latitude, longitude, elevation, battery) %>% 
        
        mutate(# assign bird ring
          ring = bird_ID,
          
          # assign sex of bird
          sex = bird_sex, 
          
          # assign bird color combo
          code = bird_code,
          
          # assign bird species
          species = species,
          
          # assign bird population
          population = population,
          
          satellites = as.character(satellites)) %>% 
        
        # make the dataframe a SpatialPointsDataFrame and define coordinates
        `coordinates<-` (c("longitude", "latitude")) %>% 
        
        # define projection
        `proj4string<-` (projection)
      
      # output result
      Tag
    }
    else if(tag_model == "PinPoint-10"){
      if(n_slice == 0){
        # read data file and extract data
        Tag <- 
          read.table(sep = "", na.strings = "", file = data_loc, fill = TRUE,
                     stringsAsFactors = FALSE, header = TRUE) %>% 
          
          mutate(
            # extract the temporal information from the string
            year = paste0("20", str_sub(string = RTC.date, start = 1, end = 2)),
            month = paste0(str_sub(string = RTC.date, start = 4, end = 5)),
            day = paste0(str_sub(string = RTC.date, start = 7, end = 8)),
            hour = paste0(str_sub(string = RTC.time, start = 1, end = 2)),
            minute = paste0(str_sub(string = RTC.time, start = 4, end = 5)),
            second = paste0(str_sub(string = RTC.time, start = 7, end = 8))
          ) %>% 
          
          mutate(
            # Merge the time and date columns together to formulate the time stamp for a given row
            timestamp = ISOdate(year = year, month = month, day = day, 
                                hour = hour, min = minute, sec = second, 
                                tz = time_zone),
            
            # Tag$datetime[nrow(Tag)] = Tag$datetime[nrow(Tag)] + 8 * 60 * 60,
            # 
            # Tag$hour[nrow(Tag)] = as.character(as.numeric(Tag$hour[nrow(Tag)]) + 8),
            # 
            # timestamp = paste0(year, "-", month, "-", day, " ", hour, ":", minute, ":", second)
            
            timestamp_simple = as.Date(str_sub(as.character(timestamp), 
                                               start = 1, end = 10), 
                                       format = "%Y-%m-%d"),          
            # make a fix number column
            fix_number = str_pad(row.names(.), 2, pad = "0"),
            
            # assign name of tag
            tag_ID = tag_ID
          ) %>% 
          
          # remove observations without a reliable location
          dplyr::select(tag_ID, timestamp_simple, fix_number, timestamp, 
                        Sats, Latitude, Longitude, Altitude.m.) %>% 
          
          `colnames<-` (tolower(names(.))) %>% 
          
          rename(satellites = sats,
                 tag_ID = tag_id,
                 elevation = altitude.m.) %>% 
          
          mutate(battery = NA,
            # assign bird ring
            ring = bird_ID,
            
            # assign sex of bird
            sex = bird_sex, 
            
            # assign bird color combo
            code = bird_code,
            
            # assign bird species
            species = species,
            
            # assign bird population
            population = population,
            
            satellites = as.character(satellites)) %>% 
          
          # remove observations without a reliable location
          filter(latitude != 0 | !is.na(latitude)) %>% 
          
          # make the dataframe a SpatialPointsDataFrame and define coordinates
          `coordinates<-` (c("longitude", "latitude")) %>% 
          
          # define projection
          `proj4string<-` (projection)
        
        # output result
        Tag
      }
      else{
        # read data file and extract data
        Tag <- 
          read.table(sep = "", na.strings = "", file = data_loc, fill = TRUE,
                     stringsAsFactors = FALSE, header = TRUE) %>% 
          
          # remove first observation (calibration fix)
          slice(-(n_slice/n_slice):(n_slice * -1)) %>%
          
          mutate(
            # extract the temporal information from the string
            year = paste0("20", str_sub(string = RTC.date, start = 1, end = 2)),
            month = paste0(str_sub(string = RTC.date, start = 4, end = 5)),
            day = paste0(str_sub(string = RTC.date, start = 7, end = 8)),
            hour = paste0(str_sub(string = RTC.time, start = 1, end = 2)),
            minute = paste0(str_sub(string = RTC.time, start = 4, end = 5)),
            second = paste0(str_sub(string = RTC.time, start = 7, end = 8))
          ) %>% 
          
          mutate(
            # Merge the time and date columns together to formulate the time stamp for a given row
            timestamp = ISOdate(year = year, month = month, day = day, 
                                hour = hour, min = minute, sec = second, 
                                tz = time_zone),
            
            # Tag$datetime[nrow(Tag)] = Tag$datetime[nrow(Tag)] + 8 * 60 * 60,
            # 
            # Tag$hour[nrow(Tag)] = as.character(as.numeric(Tag$hour[nrow(Tag)]) + 8),
            # 
            # timestamp = paste0(year, "-", month, "-", day, " ", hour, ":", minute, ":", second)
            
            timestamp_simple = as.Date(str_sub(as.character(timestamp), 
                                               start = 1, end = 10), 
                                       format = "%Y-%m-%d"),          
            # make a fix number column
            fix_number = str_pad(row.names(.), 2, pad = "0"),
            
            # assign name of tag
            tag_ID = tag_ID
          ) %>% 
          
          # remove observations without a reliable location
          dplyr::select(tag_ID, timestamp_simple, fix_number, timestamp, 
                        Sats, Latitude, Longitude, Altitude.m.) %>% 
          
          `colnames<-` (tolower(names(.))) %>% 
          
          rename(satellites = sats,
                 tag_ID = tag_id,
                 elevation = altitude.m.) %>% 
          
          mutate(battery = NA,
            # assign bird ring
            ring = bird_ID,
            
            # assign sex of bird
            sex = bird_sex, 
            
            # assign bird color combo
            code = bird_code,
            
            # assign bird species
            species = species,
            
            # assign bird population
            population = population,
            
            satellites = as.character(satellites)) %>% 
          
          # remove observations without a reliable location
          filter(latitude != 0 | !is.na(latitude)) %>% 
          
          # make the dataframe a SpatialPointsDataFrame and define coordinates
          `coordinates<-` (c("longitude", "latitude")) %>% 
          
          # define projection
          `proj4string<-` (projection)
        
        # output result
        Tag
      }
    }
    
    else{
      print("Unknown tag_model. Options are 'PinPoint-10' or 'nanoFix-mini'.")
    }
  }
```

### wrangle GPS data
```{r}
library(sp)
NFTag55843_nz <- 
  import_plover_tag_spatial_fun(data_loc = "data/GPS/Tag55843/Obs161122_192740_Tag55843.pos",
                                tag_ID = "NF55843", projection = CRS("+init=epsg:4326 +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"),
                                time_zone = "Europe/London", tag_model = "nanoFix-mini", n_slice = 0,
                                bird_ID = "CP9042", bird_code = "FWX.RR|MX.YY", bird_sex = "F", species = "BADO", population = "kaikoura")

NFTag20865_nz <- 
  import_plover_tag_spatial_fun(data_loc = "data/GPS/Tag20865/Obs261022_231825_Tag20865.pos",
                                tag_ID = "NF20865", projection = CRS("+init=epsg:4326 +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"),
                                time_zone = "Europe/London", tag_model = "nanoFix-mini", n_slice = 0,
                                bird_ID = "CP9055", bird_code = "FWX.RR|MX.LR", bird_sex = "M", species = "BADO", population = "kaikoura")

NFTag21146_nz <- 
  import_plover_tag_spatial_fun(data_loc = "data/GPS/Tag21146/Obs261022_234604_Tag21146.pos",
                                tag_ID = "NF21146", projection = CRS("+init=epsg:4326 +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"),
                                time_zone = "Europe/London", tag_model = "nanoFix-mini", n_slice = 0,
                                bird_ID = "CP9098", bird_code = "XX.RW|MX.LB", bird_sex = "F", species = "BADO", population = "kaikoura")

NFTag55687_nz <- 
  import_plover_tag_spatial_fun(data_loc = "data/GPS/Tag55687/Obs261022_232953_Tag55687.pos",
                                tag_ID = "NF55687", projection = CRS("+init=epsg:4326 +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"),
                                time_zone = "Europe/London", tag_model = "nanoFix-mini", n_slice = 0,
                                bird_ID = "CP9032", bird_code = "XX.RB|MX.BR", bird_sex = "M", species = "BADO", population = "kaikoura")

NFTag55660_nz <- 
  import_plover_tag_spatial_fun(data_loc = "data/GPS/Tag55660/Obs031222_180904_Tag55660.pos",
                                tag_ID = "NF55660", projection = CRS("+init=epsg:4326 +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"),
                                time_zone = "Europe/London", tag_model = "nanoFix-mini", n_slice = 0,
                                bird_ID = "CP9066", bird_code = "XX.RB|MX.BY", bird_sex = "F", species = "BADO", population = "kaikoura")

NFTag55795_nz <- 
  import_plover_tag_spatial_fun(data_loc = "data/GPS/Tag55795/Obs261022_233831_Tag55795.pos",
                                tag_ID = "NF55795", projection = CRS("+init=epsg:4326 +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"),
                                time_zone = "Europe/London", tag_model = "nanoFix-mini", n_slice = 0,
                                bird_ID = "CP9096", bird_code = "XX.RW|MX.BY", bird_sex = "F", species = "BADO", population = "kaikoura")

pre_2024_gps_data <- 
  bind_rows(as.data.frame(NFTag55843_nz),
            as.data.frame(NFTag20865_nz), as.data.frame(NFTag21146_nz),
            as.data.frame(NFTag55687_nz), as.data.frame(NFTag55660_nz),
            as.data.frame(NFTag55795_nz))  %>% 
  mutate(date_local = as.POSIXct(with_tz(ymd_hms(timestamp, tz = 'UTC'), 'Pacific/Auckland')),
         site = "KK") %>% 
  mutate(parent = sapply(.$code, extract_and_merge)) %>% 
  dplyr::select(-c(timestamp, timestamp_simple, fix_number, satellites, elevation, species, population, code)) %>% 
  rename(volt = battery,
         tagID = tag_ID,
         field_sex = sex) 

pre_2024_gps_data_ <- 
  read_sheet("https://docs.google.com/spreadsheets/d/1Tp26Z23HSXXZSoGXD4dbP3xukhrY1kWhzQrbtRHt4EY/edit?usp=sharing", 
             sheet = "Captures", col_types = "c") %>% 
  dplyr::filter(age == "A" & site == "KK") %>% 
  filter(species == "BADO") %>% 
  mutate(tag = ifelse(code == "XX.RR|MX.RG" & year == "2021", "66891_1",
                      ifelse(tag == "66891" & year == "2022", "66891_2", 
                             ifelse(code == "XX.RW|MX.LG", "234673", tag))),
         date = ifelse(code == "XX.RW|MX.LG", "2610",
                       ifelse(code == "XX.RR|MX.RG", "1410", date)),
         year = ifelse(code == "XX.RW|MX.LG", "2022",
                       ifelse(code == "XX.RR|MX.RG", "2021", year))) %>% 
  filter(!is.na(date)) %>% 
  mutate(date = paste(year, ifelse(nchar(date) == 3,
                                   substring(date, first = 2, last = 3),
                                   substring(date, first = 3, last = 4)),
                      ifelse(nchar(date) == 3,
                             substring(date, first = 1, last = 1),
                             substring(date, first = 1, last = 2)),
                      sep = "-") %>% ymd()) %>% 
  mutate(time = str_pad(time, width = 4, side = "left", pad = "0")) %>% 
  mutate(time = paste0(substr(time, 1, 2), ":", substr(time, 3, 4), ":00") %>% as_hms) %>% 
  # mutate(date_dep = ymd_hms(paste(date, time, sep = " "), tz = 'Pacific/Auckland')) %>% 
  mutate(date_dep = as.POSIXct(with_tz(ymd_hms(paste(date, time, sep = " "), tz = 'Pacific/Auckland'), 'Pacific/Auckland'))) %>%
  dplyr::select(ring, site, code, tag, field_sex, date_dep) %>% 
  filter(!is.na(tag) & nchar(tag) > 1) %>% 
  group_by(ring) %>% 
  arrange(date_dep) %>% 
  slice(1) %>% 
  left_join(pre_2024_gps_data %>% dplyr::select(-c(site, field_sex)), ., by = "ring") %>% 
  mutate(time_since_deployment = date_local - date_dep) %>% 
  dplyr::select(-c(code, tag))

```

### wrangle 2024 PTT data
```{r}
# establish a connection to the entire database (i.e., that I have access to)
con = dbcon()
# connect to the FIELD_2024_BADOatNZ local database
dbExecute(con, "USE FIELD_2024_BADOatNZ")
caps_2024 <-
  dbq(con, "SELECT * FROM CAPTURES") %>% 
  rowwise() %>% 
  mutate(time_cap = as.hms(max(cap_start, caught, released, na.rm = TRUE))) %>% 
  mutate(date_dep = as.POSIXct(with_tz(ymd_hms(paste(date, time_cap, sep = " "), tz = 'Pacific/Auckland'), 'Pacific/Auckland'))) %>% 
  dplyr::select(ring, field_sex, site, date_dep, tag_id) %>% 
  rename(tagID = tag_id)

tag_data_2024 <-
  bind_rows(read.csv("data/PTT/ArgosData_2024_12_19_19_41_20.csv", stringsAsFactors = FALSE),
            read.csv("data/PTT/ArgosData_2024_12_19_19_40_37.csv", stringsAsFactors = FALSE),
            read.csv("data/PTT/ArgosData_2024_12_19_19_39_43.csv", stringsAsFactors = FALSE),
            read.csv("data/PTT/ArgosData_2024_12_19_19_38_57.csv", stringsAsFactors = FALSE),
            read.csv("data/PTT/ArgosData_2024_12_19_19_38_33.csv", stringsAsFactors = FALSE),
            read.csv("data/PTT/ArgosData_2024_12_19_19_37_26.csv", stringsAsFactors = FALSE),
            read.csv("data/PTT/ArgosData_2024_12_19_19_36_30.csv", stringsAsFactors = FALSE),
            read.csv("data/PTT/ArgosData_2024_12_19_19_35_42.csv", stringsAsFactors = FALSE),
            read.csv("data/PTT/ArgosData_2024_12_19_19_34_57.csv", stringsAsFactors = FALSE),
            read.csv("data/PTT/ArgosData_2024_12_19_19_33_16.csv", stringsAsFactors = FALSE)) %>% 
  mutate(temp = (0.474 * SENSOR.01) - 35.662,
         volt = (0.0079 * SENSOR.02) + 2.4129,
         acc = SENSOR.04) %>% 
  dplyr::select(Platform.ID.No., 
                Loc..date, 
                Loc..quality, 
                Longitude, 
                Latitude, 
                # Semi.major.axis, 
                # Semi.minor.axis, 
                # Ellipse.orientation, 
                temp, volt, acc) %>% 
  rename(tagID = Platform.ID.No.,
         date = Loc..date,
         locationClass = Loc..quality,
         longitude = Longitude,
         latitude = Latitude#,
         # smaj = Semi.major.axis,
         # smin = Semi.minor.axis,
         # eor = Ellipse.orientation
         ) %>% 
  mutate(date_ = as_datetime(date),
         tagID = as.character(tagID)) %>% 
  mutate(date_local = as.POSIXct(with_tz(ymd_hms(date, tz = 'UTC'), 'Pacific/Auckland'))) %>% 
  left_join(., caps_2024, by = "tagID") %>% 
         filter(date_local >= date_dep) %>% 
         filter(!is.na(volt)) %>% 
         # dplyr::select(-temp) %>% 
         distinct() %>% 
  mutate(time_since_deployment = date_local - date_dep) %>% 
  filter(tagID != "266470") %>% 
  dplyr::select(tagID, ring, field_sex, site, date_local, locationClass, longitude, latitude, volt, temp, time_since_deployment, date_dep) %>% 
  dplyr::select(-c(locationClass))
```

### wrangle pre-2024 PTT data
```{r}
# wrangle KK PTT data
tag_date_info <-
  read_excel(here("data/tag_deploy_retrieve_dates.xlsx"), 
                     col_types = "text") %>%
  mutate(recapture_date = as.Date(as.POSIXct(as.numeric(recapture_date) * 86400, origin = "1899-12-30", tz = "UTC")),
         last_argos_data = as.Date(as.POSIXct(as.numeric(last_argos_data) * 86400, origin = "1899-12-30", tz = "UTC")),
         deployment_date = as.Date(as.POSIXct(as.numeric(deployment_date) * 86400, origin = "1899-12-30", tz = "UTC")))

pre_2024_argos_data <-
  dbq(q = "SELECT * FROM ARGOS.2022_BADO") %>% 
  bind_rows(dbq(q = "SELECT * FROM ARGOS.2020_BADO")) %>% 
  mutate(temp = (0.474 * S1) - 35.662,
         volt = (0.0079 * S2) + 2.4129) %>% 
  mutate(date_local = with_tz(locationDate, 'Pacific/Auckland')) %>% 
  distinct() %>% 
  mutate(tagID = ifelse(tagID == "66891" & date_local <= as.POSIXct("2022-10-13 12:00:00", tz = 'Pacific/Auckland'), "66891_1",
                        ifelse(tagID == "66891" & date_local > as.POSIXct("2022-10-13 12:00:00", tz = 'Pacific/Auckland'), "66891_2", tagID))) %>% 
  dplyr::select(tagID, date_local, locationClass, latitude, longitude, temp, volt) %>% 
  mutate(tagID = as.character(tagID))

# BADO google sheets
pre_2024_tag_data <-
  read_sheet("https://docs.google.com/spreadsheets/d/1Tp26Z23HSXXZSoGXD4dbP3xukhrY1kWhzQrbtRHt4EY/edit?usp=sharing", 
             sheet = "Captures", col_types = "c") %>% 
  dplyr::filter(age == "A" & site == "KK") %>% 
  filter(species == "BADO") %>% 
  mutate(tag = ifelse(code == "XX.RR|MX.RG" & year == "2021", "66891_1",
                      ifelse(tag == "66891" & year == "2022", "66891_2", 
                             ifelse(code == "XX.RW|MX.LG", "234673", tag))),
         date = ifelse(code == "XX.RW|MX.LG", "2610",
                       ifelse(code == "XX.RR|MX.RG", "1410", date)),
         year = ifelse(code == "XX.RW|MX.LG", "2022",
                       ifelse(code == "XX.RR|MX.RG", "2021", year))) %>% 
  filter(!is.na(date)) %>% 
  mutate(date = paste(year, ifelse(nchar(date) == 3,
                                   substring(date, first = 2, last = 3),
                                   substring(date, first = 3, last = 4)),
                      ifelse(nchar(date) == 3,
                             substring(date, first = 1, last = 1),
                             substring(date, first = 1, last = 2)),
                      sep = "-") %>% ymd()) %>% 
  mutate(time = str_pad(time, width = 4, side = "left", pad = "0")) %>% 
  mutate(time = paste0(substr(time, 1, 2), ":", substr(time, 3, 4), ":00") %>% as_hms) %>% 
  # mutate(date_dep = ymd_hms(paste(date, time, sep = " "), tz = 'Pacific/Auckland')) %>% 
  mutate(date_dep = as.POSIXct(with_tz(ymd_hms(paste(date, time, sep = " "), tz = 'Pacific/Auckland'), 'Pacific/Auckland'))) %>%
  dplyr::select(ring, site, code, tag, field_sex, date_dep) %>% 
  filter(!is.na(tag) & nchar(tag) > 1) %>% 
  mutate(parent = sapply(.$code, extract_and_merge)) %>% 
  left_join(., tag_date_info, by = "parent") %>% 
  filter(tag_type == "PTT") %>% 
  rename(tagID = tag) %>% 
  dplyr::select(ring, site, tagID, field_sex, date_dep, parent) %>% 
  left_join(pre_2024_argos_data, ., by = "tagID") %>% 
  filter(date_local >= date_dep) %>% 
  mutate(time_since_deployment = date_local - date_dep) %>% 
  dplyr::select(-c(locationClass))

# bind_rows(pre_2024_gps_data, pre_2024_tag_data)


# Need to check the following photos to see if RBWR has tag still ("tag seen missing in 30.08.23, assumed to have fallen off during winter (last seen with tag 26.07.2023)":
# E:/Dotterel Observations/2023/October/2023_10_11 Dot ob CG WT/IMG_7311.JPG
# E:/Dotterel Observations/2023/November/2023_11_01 Dot ob Sb ro Ph/IMG_9427.JPG
# E:/Dotterel Observations/2023/November/2023_11_06 Afternoon dot ob CG to SBC/IMG_0174.JPG
# E:/Dotterel Observations/2023/November/2023_11_06 Afternoon dot ob CG to SBC/IMG_0186.JPG
# E:/Dotterel Observations/2023/November/2023_11_13 Dot ob CG to Ph/IMG_1111.JPG
# E:/Dotterel Observations/2023/December/2023_12_23 Dot ob/IMG_7447.JPG
# E:/Dotterel Observations/2023/December/2023_12_28 Dob ob/IMG_7770.JPG
# E:/Dotterel Observations/2024/January/2024_01_05 Dot Check SSB to Clealls/IMG_9780.JPG
# E:/Dotterel Observations/2024/January/2024_01_06 Dot check Clealls to SSB/IMG_9794.JPG
# E:/Dotterel Observations/2024/January/2024_01_21 Dot ob with Ben/IMG_4124.JPG
# E:/Dotterel Observations/2024/January/2024_01_21 Dot ob with Ben/IMG_4212.JPG
# E:/Dotterel Observations/2024/February/2024_02_12 Dot ob SB/IMG_6589.JPG
# E:/Dotterel Observations/2024/February/2024_02_12 Dot ob SB/IMG_6619.JPG

# Need to check the following photos to see if RBOG has tag still ("tag likely fell off on 23.11.22 - a day after release"):
# E:/Dotterel Observations/2022/November/2022_11_15 Dot nest NPG/IMG_0011.JPG
# E:/Dotterel Observations/2023/January/2023_01_17 Dot ob/IMG_6505.JPG
# E:/Dotterel Observations/2023/January/2023_01_17 Dot ob/IMG_7118.JPG
# E:/Dotterel Observations/2023/March/2023_03_17 Dot JA arrival back of RRGO/IMG_0007.JPG
# E:/Dotterel Observations/2023/March/2023_03_17 Dot JA arrival back of RRGO/IMG_0198.JPG
# E:/Dotterel Observations/2023/March/2023_03_31 Dot ob Point to JA/IMG_0192.JPG
```

### bind all tag data together
```{r}
str(tag_data_2024)
str(pre_2024_gps_data_)
str(pre_2024_tag_data)

names(tag_data_2024) %>% sort()
names(pre_2024_gps_data_) %>% sort()
names(pre_2024_tag_data) %>% sort()

all_BADO_tagging_data <- 
  bind_rows(pre_2024_gps_data_ %>% mutate(tag_type = "GPS"), 
            tag_data_2024 %>% mutate(tag_type = "PTT"), 
            pre_2024_tag_data %>% mutate(tag_type = "PTT")) %>% 
  dplyr::select(ring, parent, site, field_sex, tagID, tag_type, date_dep, 
                date_local, temp, volt, latitude, longitude, 
                time_since_deployment)
```

### plot of tag data collected over time
```{r}
all_BADO_tagging_data %>% 
  filter(site == "KK") %>% 
  group_by(parent, tag_type) %>% 
  summarise(min_time = duration(0),
            max_time = max(time_since_deployment, na.rm = TRUE)) %>%
  # mutate(ring = factor(ring, levels = c("CP9098" , "CP9042" , "CP9055" , "CP9032" , "CP9096" , "CP9066" , "CP16134", "CP16111", "CP16607" ,"CP16617", "CP16918", "CP16905" ,"CP16609", "CP16616", "CP9068" , "CP9099"))) %>% 
  mutate(parent = factor(parent, levels = c("RWLB", "RRYY", "RRLR", "RBBR", "RWBY", "RBBY", "RBOG", "RBGB", "RROW", "RBWO", "RRGO", "RRRG", "RBOY", "RBWR", "RBRL", "RWLG"))) %>% 
  pivot_longer(
    cols = c(min_time, max_time),
    names_to = "time_type",
    values_to = "time") %>% 
  mutate(time_days = time/86400) %>% 
  ggplot() +
  geom_line(aes(y = parent, x = time_days, color = tag_type))

custom_fill_ <- brewer.pal(9, "Pastel1")[c(2, 3)]

tag_type_facets <- c('GPS' = "1.3g archival GPS tag", 
                     'PTT' = "1.8g Argos PTT tag")

facets <- 
  data.frame(parent = c("RLYL", "RWBG", "RLYR", "RRBR", "RBBY", "RWBY", "RBBR", "RRLR", "RRYY", "RWLB", rev(c("RBOG", "RBGB", "RROW", "RBWO", "RRGO", "RRRG", "RBOY", "RBWR", "RBRL", "RWLG"))),
             label = c("tag retrieved but no data onboard", "tag retrieved but no data onboard", "bird did not return", "bird did not return", rep(NA, 16)),
             tag_type = c(rep("GPS", 10), rep("PTT", 10))) %>% 
  mutate(parent = factor(parent,
                         levels = c("RLYL", "RWBG", "RLYR", "RRBR", "RBBY", "RWBY", "RBBR", "RRLR", "RRYY", "RWLB", rev(c("RBOG", "RBGB", "RROW", "RBWO", "RRGO", "RRRG", "RBOY", "RBWR", "RBRL", "RWLG")))))

tag_data_plot <- 
  all_BADO_tagging_data %>% 
  filter(site == "KK") %>% 
  mutate(ring = factor(ring, levels = c("CP9098" , "CP9042" , "CP9055" , "CP9032" , "CP9096" , "CP9066" , "CP16134", "CP16111", "CP16607" ,"CP16617", "CP16918", "CP16905" ,"CP16609", "CP16616", "CP9068" , "CP9099"))) %>%
  mutate(parent = factor(parent,
                         levels = c("RLYL", "RWBG", "RLYR", "RRBR", "RBBY", "RWBY", "RBBR", "RRLR", "RRYY", "RWLB", rev(c("RBOG", "RBGB", "RROW", "RBWO", "RRGO", "RRRG", "RBOY", "RBWR", "RBRL", "RWLG"))))) %>%
  mutate(time_days = time_since_deployment/86400) %>% 
  ggplot() +
  geom_jitter(aes(y = parent, x = time_days, fill = tag_type), shape = 21, alpha = 0.5, height = 0.1, size = 3, color = "grey30") +
  theme_minimal() +
  # geom_point(data = tag_date_info %>% 
  #              mutate(diff = recapture_date - deployment_date,
  #                     parent = factor(parent,
  #                        levels = c("RLYL", "RWBG", "RLYR", "RRBR", "RBBY", "RWBY", "RBBR", "RRLR", "RRYY", "RWLB", rev(c("RBOG", "RBGB", "RROW", "RBWO", "RRGO", "RRRG", "RBOY", "RBWR", "RBRL", "RWLG"))))
  #                     ),
  #            aes(x = diff, y = parent)) +
  geom_text(data = facets, aes(x = 0, y = parent, label = label), hjust = 0, size = 3, fontface = "italic") +
  facet_wrap("tag_type", scales = "free_y", labeller = as_labeller(tag_type_facets)) +
  scale_fill_manual(values = custom_fill_) +
  theme(legend.position = "none",
        strip.text = element_text(size = 12)) +
  ylab("bird identity") +
  xlab("days since tag deployment")
  # scale_color_manual(values = custom_fill_)


  
```

```{r}
all_BADO_tagging_data_sf <- 
  all_BADO_tagging_data %>% 
  filter(site == "KK") %>% 
  st_as_sf(., 
           coords = c("longitude", "latitude"),
           crs = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")

all_BADO_tagging_data_sf %>% 
          filter(parent == "RBWR") %>% 
          mutate(time_days = time_since_deployment/86400) %>% 
          filter(time_days > 200) %>% 
mapview(., zcol = "tagID")
```



```{r}
KK_caps %>% 
  filter(date_local > recapture_date)




BADO_PTTs_all <-
  BADO_PTTs %>% 
  sfc_as_cols(., names = c("longitude", "latitude")) %>% 
  st_drop_geometry() %>% 
  mutate(date_dep = as.POSIXct(with_tz(ymd_hms(paste(date, "00:00:00", sep = " "), tz = 'Pacific/Auckland'), 'Pacific/Auckland'))) %>% 
  mutate(date_local = as.POSIXct(with_tz(ymd_hms(locationDate, tz = 'UTC'), 'Pacific/Auckland')),
         site = "KK") %>%
  rename(id = tagID,
         lc = locationClass,
         field_sex = sex) %>% 
  mutate(time_since_deployment = date_local - date_dep) %>% 
  dplyr::select(id, ring, field_sex, site, date_local, lc, lon, lat, volt, temp, time_since_deployment) %>% arrange(desc(date_local))
  bind_rows(., argos_data)

ggplot(data = BADO_PTTs_all) +
  geom_line(aes(x = time_since_deployment, y = volt, group = id), alpha = 0.5) +
  facet_wrap("site", nrow = 2)

voltage_lmer <- 
  lmer(scale(volt) ~ scale(time_since_deployment) + (1|id) + (1|site), data = argos_data)

tidy_voltage_lmer <-
  tidy(voltage_lmer, conf.int = TRUE, conf.method = "boot", nsim = 1000)

summary(voltage_lm)
tidy
plot(allEffects(voltage_lm))
```



```{r}

### import and wrangle ----
# 2024 data 
# establish a connection to the entire database (i.e., that I have access to)
con = dbcon()

# connect to the FIELD_2024_BADOatNZ local database
dbExecute(con, "USE FIELD_2024_BADOatNZ")

# query to select everything from the "incoming" table
# caps_2024 <-
  dbq(con, "SELECT * FROM CAPTURES") %>% 
    filter(nchar(tag_id) == 6) %>% arrange(tag_id) %>% pull(tag_id) %>% unique() %>% .[1:10] %>% paste(., collapse = ", ")
  filter(age != "J") %>% 
  rowwise() %>%
  mutate(time = as_hms(min(cap_start, caught, released, na.rm = TRUE))) %>% 
    mutate(UL = ifelse(is.na(UL) | UL == "" | UL == "X", "XX", UL),
           LL = ifelse(is.na(LL) | LL == "" | LL == "X", "XX", LL),
           UR = ifelse(is.na(UR) | UR == "" | UR == "X", "XX", UR),
           LR = ifelse(is.na(LR) | LR == "" | LR == "X", "XX", LR)) %>% 
    mutate(UL = ifelse(UL == "M", "MX", UL),
           UR = ifelse(UR == "M", "MX", UR)) %>% 
  mutate(code = paste0(UL,".", LL, "|", UR,".", LR)) %>% 
  mutate(code = str_remove_all(code, ",")) %>% 
  dplyr::select(site, ring, code, field_sex, age, date, time, weight, culmen, tarsus, total_head, wing, wt_w_tag, tag_action, tag_id) %>%
  # remove pre-nesting females (weights are confounded by oogenisis)
  filter(ring != "CP19336" & weight != 66.6) %>% 
  filter(ring != "CP9088" & weight != 75.2) %>% 
  filter(ring != "CP16483" & weight != 63.8)# %>% 
  # filter(ring == "CP16134")

# scidb
con <- dbo::dbcon(server = "scidb_replica")

KK_PTT_data <- 
  dbq(q = "SELECT * FROM ARGOS.2022_BADO") %>% 
  bind_rows(dbq(q = "SELECT * FROM ARGOS.2020_BADO")) %>% 
  filter(longitude > 100 & latitude < 0) %>% 
  mutate(temp = (0.474 * S1) - 35.662,
         volt = (0.0079 * S2) + 2.4129) %>% 
  dplyr::select(tagID, locationDate, locationClass, latitude, longitude, temp, volt) %>% 
  distinct() %>% 
  mutate(source = "tag")

# BADO google sheets
BADO_caps_raw <- 
  read_sheet("https://docs.google.com/spreadsheets/d/1Tp26Z23HSXXZSoGXD4dbP3xukhrY1kWhzQrbtRHt4EY/edit#gid=1382609695", 
            sheet = "Captures", col_types = "c") 

BADO_resights_raw <- 
  read_sheet("https://docs.google.com/spreadsheets/d/1Tp26Z23HSXXZSoGXD4dbP3xukhrY1kWhzQrbtRHt4EY/edit#gid=1382609695", 
             sheet = "Resights", col_types = "c")

#### custom functions ----
sfc_as_cols <- function(x, geometry, names = c("x","y")) {
  if (missing(geometry)) {
    geometry <- sf::st_geometry(x)
  } else {
    geometry <- rlang::eval_tidy(enquo(geometry), x)
  }
  stopifnot(inherits(x,"sf") && inherits(geometry,"sfc_POINT"))
  ret <- sf::st_coordinates(geometry)
  ret <- tibble::as_tibble(ret)
  stopifnot(length(names) == ncol(ret))
  x <- x[ , !names(x) %in% names]
  ret <- setNames(ret,names)
  dplyr::bind_cols(x,ret)
}

# function that does the opposite of "%in%"
`%!in%` = Negate(`%in%`)

#### wrangle Argos and banding data

# classify PTT color combos
PTTs <- 
  c("XX.RB|MX.RL", "XX.RR|MX.RG", "XX.RR|MX.GO", "XX.RR|MX.OW", "XX.RB|MX.WO",
    "XX.RB|MX.WR", "XX.RB|MX.OG", "XX.RB|MX.GB", "XX.RW|MX.LG", "XX.RB|MX.OY")#,
    # "MX.YY|XX.BO", "MX.YY|XX.BY", "MX.YY|XX.BW", "MX.YY|XX.BR", "MX.YW|XX.GW", 
    # "MX.YW|XX.BY", "MX.YW|XX.RG")

# wrangle coordinate system of cap and resight data
BADO_resights <-
  BADO_resights_raw %>% 
  filter(utm != "WGS87") %>% 
  filter(!is.na(easting)) %>% 
  st_as_sf(., coords = c("easting", "northing"), crs = 2193) %>% 
  st_transform(., crs = 4326) %>% 
  sfc_as_cols(., names = c("longitude", "latitude")) %>% 
  st_drop_geometry() %>%
  bind_rows(BADO_resights_raw %>% filter(utm == "WGS87") %>% 
              rename(latitude = northing, longitude = easting) %>% 
              mutate(longitude = as.numeric(longitude),
                     latitude = as.numeric(latitude))) %>% 
  filter(sex != "J") %>% 
  filter(site %!in% c("KT", "KK")) %>%
  mutate(date = paste(year, 
                       ifelse(nchar(date) == 3, 
                              str_sub(date, start = 2, end = 3), 
                              str_sub(date, start = 3, end = 4)), 
                       ifelse(nchar(date) == 3, 
                              str_sub(date, start = 1, end = 1), 
                              str_sub(date, start = 1, end = 2)), 
                       sep = "-") %>% as.Date(., format = "%Y-%m-%d")) %>% 
  left_join(., BADO_caps_raw %>% filter(sex != "J") %>% filter(!is.na(easting)) %>% dplyr::select(ring, code, tag),
            by = "code") %>%
  mutate(source = "resight") %>% 
  st_as_sf(., 
           coords = c("longitude", "latitude"),
           crs = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0") %>% 
  mutate(status = ifelse(code %in% PTTs, "tag", "no-tag")) %>%
  mutate(tag = ifelse(tag == "66891" & year == "2021", "66891_1",
                      ifelse(tag == "66891" & year == "2022", "66891_2", tag))) %>% 
  rename(tagID = tag) %>% 
  dplyr::select(source, ring, code, sex, date, tagID, status)

BADO_caps <-
  BADO_caps_raw %>% 
  filter(utm != "WGS87") %>% 
  mutate(easting = as.numeric(easting),
         northing = as.numeric(northing)) %>% 
  filter(!is.na(easting)) %>% 
  st_as_sf(., coords = c("easting", "northing"), crs = 2193) %>% 
  st_transform(., crs = 4326) %>% 
  sfc_as_cols(., names = c("longitude", "latitude")) %>% 
  st_drop_geometry() %>% 
  bind_rows(., BADO_caps_raw %>% filter(utm == "WGS87") %>% 
              rename(longitude = easting, latitude = northing) %>% 
              mutate(longitude = as.numeric(longitude), latitude = as.numeric(latitude))) %>% 
  group_by(ring) %>% 
  slice(1) %>% 
  ungroup() %>% 
  mutate(tag = ifelse(code == "XX.RR|MX.RG" & year == "2021", "66891_1",
                      ifelse(tag == "66891" & year == "2022", "66891_2", 
                             ifelse(code == "XX.RW|MX.LG", "234673", tag))),
         date = ifelse(code == "XX.RW|MX.LG", "2610",
                       ifelse(code == "XX.RR|MX.RG", "1410", date)),
         year = ifelse(code == "XX.RW|MX.LG", "2022",
                       ifelse(code == "XX.RR|MX.RG", "2021", year))) %>% 
  mutate(date = paste(year, 
                      ifelse(nchar(date) == 3, 
                             str_sub(date, start = 2, end = 3), 
                             str_sub(date, start = 3, end = 4)), 
                      ifelse(nchar(date) == 3, 
                             str_sub(date, start = 1, end = 1), 
                             str_sub(date, start = 1, end = 2)), 
                      sep = "-") %>% as.Date(., format = "%Y-%m-%d")) %>% 
  rename(tagID = tag) %>% 
  mutate(source = "capture") %>% 
  dplyr::select(source, ring, code, tagID, sex, date, longitude, latitude) %>% 
  st_as_sf(., 
           coords = c("longitude", "latitude"),
           crs = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0") %>% 
  mutate(status = ifelse(code %in% PTTs, "tag", "no-tag")) %>% 
  filter(code %in% BADO_resights$code | code %in% PTTs)

#### wrangle BADO Argos data ----
BADO_PTTs <- 
  dbq(q = "SELECT * FROM ARGOS.2022_BADO") %>% 
  bind_rows(dbq(q = "SELECT * FROM ARGOS.2020_BADO")) %>% 
  filter(longitude > 100 & latitude < 0) %>% 
  mutate(temp = (0.474 * S1) - 35.662,
         volt = (0.0079 * S2) + 2.4129) %>% 
  dplyr::select(tagID, locationDate, locationClass, latitude, longitude, temp, volt) %>% 
  distinct() %>% 
  mutate(source = "tag") %>% 
  st_as_sf(., 
           coords = c("longitude", "latitude"),
           crs = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0") %>%
  sfc_as_cols(., names = c("lon", "lat")) %>%
  # filter(locationClass %in% c(1, 2, 3)) %>% 
  filter(year(locationDate) > 2020) %>%
  mutate(tagID = ifelse(tagID == "66891" & locationDate < as.Date("2022-10-28", format = "%Y-%m-%d"), "66891_1",
                      ifelse(tagID == "66891" & locationDate >= as.Date("2022-10-28", format = "%Y-%m-%d"), "66891_2", tagID))) %>%  
  left_join(., BADO_caps %>% st_drop_geometry() %>% dplyr::select(ring, code, tagID, date, sex), by = "tagID") %>% #filter(tagID == "234673")
  rename(cap_date = date,) %>% 
  filter(locationDate >= cap_date) %>% 
  mutate(date = as.Date(locationDate),
         status = "tag") #%>% 
  # dplyr::select(-cap_date, -locationClass, -locationDate, -temp, -volt)

BADO_PTTs %>% 
  pull(tagID) %>% 
  unique() %>% 
  sort() %>% 
  paste(., collapse = ", ")

sf_points = BADO_PTTs %>% filter(tagID == "234658")

# Function to create lines connecting points
create_lines <- function(sf_points) {
  line_list <- list()
  
  for (i in 1:(nrow(sf_points) - 1)) {
    line <- st_sfc(st_linestring(rbind(st_coordinates(sf_points[i, ]), st_coordinates(sf_points[i + 1, ]))))
    line_list[[i]] <- st_sf(geometry = line, time = sf_points$locationDate[i + 1])
  }
  
  do.call(rbind, line_list)
}

sf_lines <- create_lines(BADO_PTTs)

# Extract coordinates for leaflet.minicharts
coords <- sf_points %>% st_coordinates()

# Create leaflet map
leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addFlows(
    lng0 = coords[1:(nrow(coords)-1), "X"], lat0 = coords[1:(nrow(coords)-1), "Y"],
    lng1 = coords[2:nrow(coords), "X"], lat1 = coords[2:nrow(coords), "Y"],
    color = "blue",
    opacity = 0.5,  # Set transparency
    flow = TRUE,
    maxThickness = 5  # Set size (thickness) of the flow lines
  ) %>%
  addCircleMarkers(data = sf_points, color = "red", radius = 5, popup = ~as.character(locationDate))

# Ensure that the coordinate vectors are correctly handled
lng0 <- coords[1:(nrow(coords)-1), "X"]
lat0 <- coords[1:(nrow(coords)-1), "Y"]
lng1 <- coords[2:nrow(coords), "X"]
lat1 <- coords[2:nrow(coords), "Y"]

# Confirming the lengths match
length(lng0) == length(lat0) && length(lng1) == length(lat1) && length(lng0) == length(lng1)


# Create a leaflet map
map <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addCircleMarkers(data = sf_points, color = "red", radius = 5, popup = ~as.character(locationDate)) %>%
  addPolylines(data = sf_lines, color = "blue", weight = 2)

# Animate the lines
# Note: leaflet.extras doesn't directly support animation, 
# but you can use the `addTimeline` function for a simple temporal visualization.
map %>% addTimeline(data = sf_lines, timelineOptions = timelineOptions(
  styleOptions = list(
    color = "blue",
    weight = 2
  ),
  steps = 500,
  duration = 10000,
  easing = "linear"
))

mapview(BADO_PTTs%>% filter(tagID == "66891_1"), zcol = "tagID")

KK_PTT_last_dates <- 
  BADO_PTTs %>% 
  sfc_as_cols(., names = c("longitude", "latitude")) %>% 
  st_drop_geometry() %>% 
  group_by(tagID, code) %>%
  summarise(last_Argos_data = max(date))

KK_PTT_last_dates$parent <- 
  sapply(KK_PTT_last_dates$code, extract_and_merge)

KK_PTT_last_dates %>% 
  filter(str_sub(parent, 1, 1) == "R")
```


```{r}
# RBBR (MR Omaha) tag 55687 removed on 28.09.2022
# RLYL no tag 21251 on at 29.09.2022
# RRLR tag 20865 removed on 29.09.2022
# RBBY tag 55660 removed 3.12.2022 
# RRYY tag 55843 removed 16.11.2022
# RWLB (Ginger) tag 21146 removed 12.10.2022
# RWBY tag 55795 removed 02.10.2022
# RBRL (Aerial) tag 66903 recap on 19.11.21, mass 62.5
# RBGB PTT removed 03.11.2023
# RRGO PTT removed on 03.11.2023
# RRRG (Antony) PTT removed 24.10.2023 (killed by cat)
# RLYR did not return (as of 07.09.2022, all 9 other GPS birds returned, and the 2 PTTs)

# nest_fates_summary <- 
#   nest_fates %>% 
#   group_by(tag_type, state) %>% summarise(n = n_distinct(nest_id)) %>% 
#   group_by(tag_type) %>%
#   mutate(proportion = n / sum(n)) %>%
#   ungroup()
# 
# data = nest_fates_summary
# 
# # Calculate the total number of nests for each treatment group
# totals <- tapply(data$n, data$tag_type, sum)
# 
# # Add proportions to the data frame
# data$proportion <- with(data, n / totals[tag_type])
# 
# pairwise_prop_test <- function(data, group1, group2, state, hyp) {
#   subset_data <- data[data$state == state & data$tag_type %in% c(group1, group2), ]
#   counts <- subset_data$n
#   n <- totals[c(group1, group2)]
#   prop.test(t(matrix(counts)), t(matrix(n)), alternative = hyp)
# }
# 
# GPS_control_fail <- 
#   pairwise_prop_test(data = nest_fates_summary, 
#                      group1 = "GPS", group2 = "control", 
#                      state = "fail", hyp = "less")
# 
# PTT_control_fail <- 
#   pairwise_prop_test(data = nest_fates_summary, 
#                      group1 = "PTT", group2 = "control", 
#                      state = "fail", hyp = "greater")
# 
# GPS_control_hatch <- 
#   pairwise_prop_test(data = nest_fates_summary, 
#                      group1 = "GPS", group2 = "control", 
#                      state = "brood", hyp = "greater")
# 
# PTT_control_hatch <- 
#   pairwise_prop_test(data = nest_fates_summary, 
#                      group1 = "PTT", group2 = "control", 
#                      state = "brood", hyp = "less")
# 
# PTT_control_aband <- 
#   pairwise_prop_test(data = nest_fates_summary, 
#                      group1 = "PTT", group2 = "control", 
#                      state = "aband", hyp = "greater")
# 
# 
# group1 = pair[1]
# group2 = pair[2]
# # List of states
# states <- unique(nest_fates_summary$state)
# 
# # List of group pairs to compare
# group_pairs <- list(c("GPS", "control"), c("PTT", "control"), c("PTT", "GPS"))
# 
# # Perform pairwise comparisons for each state and each group pair
# results <- list()
# 
# for (state in states) {
#   for (pair in group_pairs) {
#     test_result <- pairwise_prop_test(nest_fates_summary, pair[1], pair[2], state)
#     results[[paste(state, pair[1], "vs", pair[2])]] <- test_result
#   }
# }
# 
# # Print results
# for (name in names(results)) {
#   cat("\nComparison:", name, "\n")
#   print(results[[name]])
# }
# 
# ggplot(nest_fates_summary, aes(x = tag_type, y = proportion, fill = state)) +
#   geom_bar(stat = "identity", position = "stack") +
#   labs(y = "Proportion", x = "Tag Type", title = "Proportions of States by Tag Type")
# 
# # Create the contingency table of proportions
# contingency_table <- table(nest_fates_summary$tag_type, nest_fates_summary$state)
# 
# # Perform the Chi-square test
# chisq_test <- chisq.test(contingency_table)
# 
# # View the results
# chisq_test
# 
# # Create a contingency table
# contingency_table <- table(nest_fates_summary$tag_type, nest_fates_summary$state)
# 
# # model <- multinom(state ~ tag_type + season, data = nest_fates)
# # summary(model)
# # # Obtain the summary of the model
# # model_summary <- summary(model)
# # 
# # # Extract the z values
# # z_values <- model_summary$coefficients / model_summary$standard.errors
# # 
# # # Calculate p-values
# # p_values <- 2 * (1 - pnorm(abs(z_values)))
# # 
# # # Combine coefficients, z values, and p-values into a data frame
# # results <- data.frame(
# #   Coefficients = model_summary$coefficients,
# #   Z_values = z_values,
# #   P_values = p_values
# # )
# # 
# # print(results)
```


```{r}
# Perform pairwise comparisons for tag_type effects
hypothesis(model_brm, "tag_typeGPS > control")
hypothesis(model_brm, "tag_typePTT > control")

# Summarize the coefficients
tag_type_summary <- posterior_summary(tag_type_coeffs)
print(tag_type_summary)

# View the structure of the posterior samples
str(post_samples)

# Extract fixed effects summary
fixed_effects <- 
  summary(model_brm)$fixed

# Create a data frame for easier manipulation
fixed_effects_df <- as.data.frame(fixed_effects)
fixed_effects_df$Parameter <- rownames(fixed_effects_df)

# Select and rename columns for clarity
plot_data <-
  fixed_effects_df %>%
  dplyr::select(Parameter, Estimate, `l-95% CI`, `u-95% CI`) %>%
  rename(Estimate = Estimate, 
         Q2.5 = `l-95% CI`, 
         Q97.5 = `u-95% CI`) %>%
  filter(Parameter %!in% c("muunkn_tag_typePTT", "muaband_tag_typeGPS")) %>% 
  filter(str_detect(Parameter, "unkn", negate = TRUE))
  # filter(grepl("tag_type", Parameter)) %>% 
  # filter(str_detect("muunkn", Parameter, negate = TRUE)) # Filter to include only the effects of interest (e.g., tag_type)

# Create the forest plot
ggplot(plot_data, aes(x = Estimate, y = Parameter)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = Q2.5, xmax = Q97.5), height = 0.2) +
  theme_minimal() +
  labs(title = "Effect Sizes of Tag Type on Nest State",
       x = "Estimate",
       y = "Tag Type") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red")

##
fixed_effects_df["muaband_tag_typeGPS", "Estimate"] <-
  fixed_effects_df["muaband_tag_typeGPS", "Estimate"] + fixed_effects_df["muaband_Intercept", "Estimate"]

fixed_effects_df["muaband_tag_typePTT", "Estimate"] <-
  fixed_effects_df["muaband_tag_typePTT", "Estimate"] + fixed_effects_df["muaband_Intercept", "Estimate"]

fixed_effects_df["mubrood_tag_typeGPS", "Estimate"] <-
  fixed_effects_df["mubrood_tag_typeGPS", "Estimate"] + fixed_effects_df["mubrood_Intercept", "Estimate"]

fixed_effects_df["mufail_tag_typecontrol", "Estimate"] <-
  fixed_effects_df["mufail_tag_typecontrol", "Estimate"] + fixed_effects_df["mufail_Intercept", "Estimate"]

fixed_effects_df["mufail_tag_typePTT", "Estimate"] <-
  fixed_effects_df["mufail_tag_typePTT", "Estimate"] + fixed_effects_df["mufail_Intercept", "Estimate"]

fixed_effects_df["mubrood_tag_typecontrol", "Estimate"] <-
  fixed_effects_df["mubrood_tag_typecontrol", "Estimate"] + fixed_effects_df["mubrood_Intercept", "Estimate"]

fixed_effects_df["mubrood_tag_typePTT", "Estimate"] <-
  fixed_effects_df["mubrood_tag_typePTT", "Estimate"] + fixed_effects_df["mubrood_Intercept", "Estimate"]
##
fixed_effects_df["muaband_tag_typeGPS", "lci"] <-
  fixed_effects_df["muaband_tag_typeGPS", "lci"] + fixed_effects_df["muaband_Intercept", "lci"]

fixed_effects_df["muaband_tag_typePTT", "lci"] <-
  fixed_effects_df["muaband_tag_typePTT", "lci"] + fixed_effects_df["muaband_Intercept", "lci"]

fixed_effects_df["mubrood_tag_typeGPS", "lci"] <-
  fixed_effects_df["mubrood_tag_typeGPS", "lci"] + fixed_effects_df["mubrood_Intercept", "lci"]

fixed_effects_df["mufail_tag_typecontrol", "lci"] <-
  fixed_effects_df["mufail_tag_typecontrol", "lci"] + fixed_effects_df["mufail_Intercept", "lci"]

fixed_effects_df["mufail_tag_typePTT", "lci"] <-
  fixed_effects_df["mufail_tag_typePTT", "lci"] + fixed_effects_df["mufail_Intercept", "lci"]

fixed_effects_df["mubrood_tag_typecontrol", "lci"] <-
  fixed_effects_df["mubrood_tag_typecontrol", "lci"] + fixed_effects_df["mubrood_Intercept", "lci"]

fixed_effects_df["mubrood_tag_typePTT", "lci"] <-
  fixed_effects_df["mubrood_tag_typePTT", "lci"] + fixed_effects_df["mubrood_Intercept", "lci"]
##
fixed_effects_df["muaband_tag_typeGPS", "uci"] <-
  fixed_effects_df["muaband_tag_typeGPS", "uci"] + fixed_effects_df["muaband_Intercept", "uci"]

fixed_effects_df["muaband_tag_typePTT", "uci"] <-
  fixed_effects_df["muaband_tag_typePTT", "uci"] + fixed_effects_df["muaband_Intercept", "uci"]

fixed_effects_df["mubrood_tag_typeGPS", "uci"] <-
  fixed_effects_df["mubrood_tag_typeGPS", "uci"] + fixed_effects_df["mubrood_Intercept", "uci"]

fixed_effects_df["mufail_tag_typecontrol", "uci"] <-
  fixed_effects_df["mufail_tag_typecontrol", "uci"] + fixed_effects_df["mufail_Intercept", "uci"]

fixed_effects_df["mufail_tag_typePTT", "uci"] <-
  fixed_effects_df["mufail_tag_typePTT", "uci"] + fixed_effects_df["mufail_Intercept", "uci"]

fixed_effects_df["mubrood_tag_typecontrol", "uci"] <-
  fixed_effects_df["mubrood_tag_typecontrol", "uci"] + fixed_effects_df["mubrood_Intercept", "uci"]

fixed_effects_df["mubrood_tag_typePTT", "uci"] <-
  fixed_effects_df["mubrood_tag_typePTT", "uci"] + fixed_effects_df["mubrood_Intercept", "uci"]

# Function to calculate probabilities from log odds
log_odds_to_prob <- function(log_odds) {
  exp(log_odds) / (1 + exp(log_odds))
}

fixed_effects_df_ <- 
  fixed_effects_df %>%
  filter(!is.na(Estimate)) %>% 
  mutate(across(c(Estimate, lci, uci), log_odds_to_prob)) %>% 
  as.tibble()

fixed_effects_df_a_b_G_P

fixed_effects_df_f_b_c_P <- 
  fixed_effects_df_

# Extract fixed effects summary
fixed_effects <- summary(model_brm)$fixed

# Create a data frame for easier manipulation
fixed_effects_df <- as.data.frame(fixed_effects)
fixed_effects_df$Parameter <- rownames(fixed_effects_df)

# Function to calculate probabilities from log odds
log_odds_to_prob <- function(log_odds) {
  exp(log_odds) / (1 + exp(log_odds))
}

# Extract the intercepts
intercepts <- fixed_effects_df %>%
  filter(grepl("Intercept", Parameter))

# Extract the tag type effects
tag_effects <- fixed_effects_df %>%
  filter(grepl("tag_type", Parameter))

# Calculate the probabilities for each state, including credible intervals
states <- unique(data$state)
probabilities <- data.frame(State = character(), 
                             Tag_Type = character(), 
                             Probability = numeric(), 
                             `l-95% CI` = numeric(), 
                             `u-95% CI` = numeric())

for (state in states) {
  intercept <- intercepts %>% filter(grepl(state, Parameter)) 
  intercept_est <- intercept$Estimate
  intercept_lower <- intercept$`l-95% CI`
  intercept_upper <- intercept$`u-95% CI`
  
  for (tag in levels(data$tag_type)) {
    tag_effect <- tag_effects %>% 
      filter(grepl(paste0("tag_type", tag), Parameter) & grepl(state, Parameter))
    
    # Ensure we are getting only 1 row for tag effect (should be one for each state)
    if (nrow(tag_effect) == 1) {
      tag_est <- tag_effect$Estimate
      tag_lower <- tag_effect$Q2.5
      tag_upper <- tag_effect$Q97.5
      
      # Calculate the log odds for the intercept and tag type effect
      log_odds_est <- intercept_est + tag_est
      log_odds_lower <- intercept_lower + tag_lower
      log_odds_upper <- intercept_upper + tag_upper
      
      # Convert log odds to probabilities
      prob_est <- log_odds_to_prob(log_odds_est)
      prob_lower <- log_odds_to_prob(log_odds_lower)
      prob_upper <- log_odds_to_prob(log_odds_upper)
      
      # Store the results
      probabilities <- rbind(probabilities, data.frame(State = state, 
                                                       Tag_Type = tag, 
                                                       Probability = prob_est, 
                                                       `l-95% CI` = prob_lower, 
                                                       `u-95% CI` = prob_upper))
    } else {
      message("Multiple rows found for tag_effects in state: ", state, " and tag_type: ", tag)
    }
  }
}

# Plot the probabilities with credible intervals
ggplot(probabilities, aes(x = Tag_Type, y = Probability, color = Tag_Type)) +
  geom_point(size = 3) +  # Add points for the probabilities
  geom_errorbar(aes(ymin = `l-95% CI`, ymax = `u-95% CI`), width = 0.2) +  # Add vertical error bars for the credible intervals
  facet_wrap(~State, scales = "free_y") +  # Facet by state with free y-axis scales
  scale_color_manual(values = c("control" = "blue", "PTT" = "red", "GPS" = "green", "other" = "purple")) +  # Customize colors for each tag_type
  theme_minimal() +  # Use a minimal theme
  theme(axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels for readability
        strip.text = element_text(size = 12),  # Increase size of facet labels
        legend.position = "none") +  # Remove legend (optional)
  labs(x = "Tag Type", y = "Probability", title = "Probabilities with 95% Credible Intervals")

# Extract the intercepts
intercepts <- fixed_effects_df %>%
  filter(grepl("Intercept", Parameter))

# Extract the tag type effects
tag_effects <- fixed_effects_df %>%
  filter(grepl("tag_type", Parameter))

# Calculate the probabilities for each state, including credible intervals
states <- unique(data$state)
tag_types <- unique(data$tag_type)
probabilities <- data.frame(State = character(), 
                             Tag_Type = character(), 
                             Probability = numeric(), 
                             `l-95% CI` = numeric(), 
                             `u-95% CI` = numeric())

for (state in states) {
  intercept <- intercepts %>% filter(grepl(state, Parameter)) 
  intercept_est <- intercept$Estimate
  intercept_lower <- intercept$`l-95% CI`
  intercept_upper <- intercept$`u-95% CI`
  
  for (tag in tag_types) {
    for (i in 1:nrow())
    tag_effect <- tag_effects %>% filter(grepl(paste0("tag_type", tag), Parameter)) 
    tag_est <- tag_effect$Estimate
    tag_lower <- tag_effect$`l-95% CI`
    tag_upper <- tag_effect$`u-95% CI`
    
    # Calculate the log odds for the intercept and tag type effect
    log_odds_est <- intercept_est + tag_est
    log_odds_lower <- intercept_lower + tag_lower
    log_odds_upper <- intercept_upper + tag_upper
    
    # Convert log odds to probabilities
    prob_est <- log_odds_to_prob(log_odds_est)
    prob_lower <- log_odds_to_prob(log_odds_lower)
    prob_upper <- log_odds_to_prob(log_odds_upper)
    
    # Store the results
    probabilities <- rbind(probabilities, data.frame(State = state, 
                                                     Tag_Type = tag, 
                                                     Probability = prob_est, 
                                                     `l-95% CI` = prob_lower, 
                                                     `u-95% CI` = prob_upper))
  }
}

# Print the probabilities with credible intervals
print(probabilities)

# Select and rename columns for clarity
plot_data <-
  fixed_effects_df %>%
  dplyr::select(Parameter, Estimate, `l-95% CI`, `u-95% CI`) %>%
  rename(Estimate = Estimate, 
         Q2.5 = `l-95% CI`, 
         Q97.5 = `u-95% CI`) #%>% 
  # filter(grepl("tag_type", Parameter)) %>% 
  # filter(str_detect("muunkn", Parameter, negate = TRUE)) # Filter to include only the effects of interest (e.g., tag_type)

# Create the forest plot
ggplot(plot_data, aes(x = Estimate, y = Parameter)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = Q2.5, xmax = Q97.5), height = 0.2) +
  theme_minimal() +
  labs(title = "Effect Sizes of Tag Type on Nest State",
       x = "Estimate",
       y = "Tag Type") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red")

# Reorder the levels for plotting
# plot_data$Parameter <- factor(plot_data$Parameter, 

# Plot diagnostics
plot(model_brm)

# Check R-hat values
rhat(model_brm)

# Check effective sample sizes
neff_ratio(model_brm)

# Posterior predictive checks
pp_check(model_brm)

# Generate predictions from the posterior distribution
y_rep <- posterior_predict(model_brm)

# Compare summary statistics (e.g., mean, variance) of observed vs. predicted data
pp_check(model_brm, type = "stat", stat = "mean")
pp_check(model_brm, type = "stat", stat = "var")

# Predicted counts
predicted_counts <- apply(y_rep, 2, function(col) table(factor(col, levels = levels(nest_fates$state))))
predicted_counts <- colMeans(predicted_counts)

# Observed counts
observed_counts <- table(nest_fates$state)

# Combine into a data frame for plotting
validation_data <- data.frame(
  state = levels(nest_fates$state),
  observed = as.vector(observed_counts),
  predicted = as.vector(predicted_counts)
)

# Plotting observed vs predicted counts
library(ggplot2)
ggplot(validation_data, aes(x = state)) +
  geom_bar(aes(y = observed, fill = "Observed"), stat = "identity", position = "dodge") +
  geom_bar(aes(y = predicted, fill = "Predicted"), stat = "identity", position = "dodge") +
  scale_fill_manual(name = "Count Type", values = c("Observed" = "blue", "Predicted" = "red")) +
  labs(title = "Observed vs Predicted Counts", x = "State", y = "Count")


# Residual diagnostics
residuals <- residuals(model)
plot(residuals)

# Fit the mixed-effects logistic regression model
model <- glmer(state ~ tag_type + (1 | season) + (1 | parent), 
               data = nest_fates, 
               family = binomial)

# Check the model summary
summary(model)

state_summary <-
  bind_rows(breeding_data_2021, breeding_data_2022, breeding_data_2023) %>%
  mutate(nest_id = paste(year(date), nest_id, sep = "_")) %>% 
  filter(!is.na(state)) %>% 
  group_by(nest_id, parent, tag_type) %>%
  dplyr::summarise(state = min(as.numeric(state), na.rm = TRUE)) %>% 
  group_by(tag_type, state) %>% 
  summarise(n_nests = n_distinct(nest_id)) %>% 
  mutate(state = ifelse(state == 1, "fail", 
                        ifelse(state == 2, "aband", 
                               ifelse(state == 3, "brood", 
                                      ifelse(state == 4, "unkn", "xxx"))))) %>% 
  ungroup() %>% 
  bind_rows(., data.frame(tag_type = c("GPS", "PTT"), 
                          state = c("aband", "unkn"), 
                          n_nests = c(0, 0)))

data = state_summary

# Calculate the total number of nests for each treatment group
totals <- tapply(data$n_nests, data$tag_type, sum)

# Add proportions to the data frame
data$proportion <- with(data, n_nests / totals[tag_type])

# Function to perform pairwise comparison for a given state
pairwise_prop_test <- function(data, group1, group2, state) {
  subset_data <- data[data$state == state & data$tag_type %in% c(group1, group2), ]
  counts <- subset_data$n_nests
  n <- totals[c(group1, group2)]
  prop.test(counts, n)
}


# List of states
states <- unique(data$state)

# List of group pairs to compare
group_pairs <- list(c("GPS", "control"), c("PTT", "control"), c("PTT", "GPS"))

# Perform pairwise comparisons for each state and each group pair
results <- list()

for (state in states) {
  for (pair in group_pairs) {
    test_result <- pairwise_prop_test(data, pair[1], pair[2], state)
    results[[paste(state, pair[1], "vs", pair[2])]] <- test_result
  }
}

# Print results
for (name in names(results)) {
  cat("\nComparison:", name, "\n")
  print(results[[name]])
}



contingency_table <- xtabs(proportion ~ tag_type + state, data = state_summary)
chi_square_test <- chisq.test(contingency_table)
chi_square_test

# Perform Fisher's exact test
fisher_test <- fisher.test(contingency_table)

# View the results
fisher_test

breeding_data_2021 %>% 
  filter(state == "incub") %>% View()

  #pull(state) %>% table()
  # filter(parent %in% (dat %>% filter(season == 2021) %>% pull(rings_comb) %>% unique())) %>%
  filter(nest_fate == "Occupied" | as.numeric(chicks) > 0) %>%
  group_by(parent) %>%
  arrange(desc(date)) %>%
  slice(1) %>%
  ungroup() %>%
  arrange(desc(date)) %>%
  mutate(nest_id = sub("^([^[:space:]]+).*", "\\1", NestID)) %>%
  rename(last_date_breeding = date) %>% 
  select(parent, last_date_breeding, nest_id, OBJECTID)

# import and consolidate key columns
breeding_data_2021_ <-
  read_excel(here("data/Kaikoura_Dotterel_2021_Feb2022_upd_Nov22_Locations.xlsx"), 
                     sheet = "Kaikoura_DotterelNest2021_0", 
                     col_types = "text") %>%
  mutate(hatch_date_ = as.POSIXct(as.numeric(`Date Hatched`) * 86400, origin = "1899-12-30", tz = "UTC"),
         fail_date_ = as.POSIXct(as.numeric(`Date Failed`) * 86400, origin = "1899-12-30", tz = "UTC"),
         found_date_ = as.POSIXct(as.numeric(`Date Found`) * 86400, origin = "1899-12-30", tz = "UTC")) %>% 
  mutate(hatch_date_nz = with_tz(hatch_date_, tzone = "Pacific/Auckland"),
         fail_date_nz = with_tz(fail_date_, tzone = "Pacific/Auckland"),
         found_date_nz = with_tz(found_date_, tzone = "Pacific/Auckland")) %>% 
  mutate(hatch_date = as.Date(hatch_date_nz),
         fail_date = as.Date(fail_date_nz),
         found_date = as.Date(found_date_nz)) %>%
  mutate(nest_id = sub("^([^[:space:]]+).*", "\\1", `Nest ID`)) %>% 
  select(OBJECTID, nest_id, found_date, hatch_date, fail_date)

left_join(breeding_data_2021, breeding_data_2021_, by = "nest_id") %>%
  mutate(date_check = ifelse((!is.na(found_date) & is.na(fail_date) & is.na(hatch_date)) | 
                               ((!is.na(hatch_date) & found_date < hatch_date)) | 
                               ((!is.na(fail_date) & !is.na(hatch_date)) & hatch_date < fail_date) |
                               ((!is.na(fail_date) & found_date < fail_date)), 1, 0)) %>% 
  group_by(parent) %>% 
  mutate(last_date_breeding_ = max(found_date, hatch_date, fail_date, na.rm = TRUE)) %>% 
  mutate(days_diff = last_date_breeding_ - last_date_breeding) %>% 
  arrange(desc(days_diff)) %>% 
  mutate(last_date_breeding_final = as.Date(ifelse(days_diff > 0, last_date_breeding + ceiling(days_diff/2), last_date_breeding))) %>% 
  arrange(desc(last_date_breeding_final)) %>% 
  select(parent, last_date_breeding_final) %>% 
  # specify the season as the first calender year
  mutate(season = ifelse(month(last_date_breeding_final) < 7, year(last_date_breeding_final) - 1, year(last_date_breeding_final)))
```

